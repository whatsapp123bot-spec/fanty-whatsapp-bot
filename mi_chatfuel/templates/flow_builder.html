<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OptiChat — Builder</title>
  <style>
    :root { --bg:#0f172a; --card:#0b1220; --muted:#94a3b8; --text:#e2e8f0; --primary:#7c3aed; --green:#22c55e; --red:#ef4444; --ink:#0a0f1a; }
    * { box-sizing: border-box; }
    body { margin:0; background:linear-gradient(180deg,#0b1220,#0f172a); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { padding:6px 12px; background:rgba(11,18,32,.7); border-bottom:1px solid rgba(255,255,255,.06); color:#e2e8f0; display:flex; align-items:center; justify-content:space-between; position:sticky; top:0; backdrop-filter: blur(8px); z-index:10; }
    header .brand { display:flex; align-items:center; gap:8px; font-weight:800; font-size:14px; }
    header .brand .dot { width:8px; height:8px; border-radius:50%; background: radial-gradient(circle at 30% 30%, #a78bfa, #7c3aed); box-shadow: 0 0 10px rgba(124,58,237,.7); }
  header .actions { display:flex; gap:6px; align-items:center; }
  header .actions .btn { padding:6px 10px; border-radius:10px; font-size:13px; box-shadow: 0 6px 16px rgba(124,58,237,.18); }
  .hdr-hint { font-size:11px; color:#94a3b8; margin-left:8px; opacity:.8; }
  @media (max-width: 1200px){ .hdr-hint { display:none; } }
  .btn { padding:8px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.08); cursor:pointer; color:#fff; font-weight:700; background:linear-gradient(135deg,#8b5cf6,#7c3aed); box-shadow: 0 8px 24px rgba(124,58,237,.25); }
    .btn.minor { background:#111827; color:#e5e7eb; box-shadow:none; }
    .btn.save { background: linear-gradient(135deg,#34d399,#22c55e); }
    .btn.reload { background: linear-gradient(135deg,#8b5cf6,#7c3aed); }
    .btn.add { background:#6f42c1; }
    .btn.del { background: linear-gradient(135deg,#f87171,#ef4444); }
  .status-chip { font-size:11px; padding:1px 6px; border-radius:999px; border:1px solid rgba(255,255,255,.12); color:#cbd5e1; margin-left:6px; }
    .status-chip.on { background: rgba(34,197,94,.12); border-color: rgba(34,197,94,.35); color:#bbf7d0; }
    .status-chip.off { background: rgba(148,163,184,.12); }
  .wrap { display:grid; grid-template-columns: auto 1fr; gap:10px; padding: 12px; height: calc(100vh - 60px); }
  /* Estado con sidebar colapsado: liberar todo el ancho al lienzo */
  .wrap.sidebar-collapsed { grid-template-columns: 0 1fr; gap:0; }
  .sidebar { position:relative; background: var(--card); border-radius:16px; padding:10px; overflow:auto; border:1px solid rgba(255,255,255,.06); width:220px; min-width:180px; max-width:360px; resize: horizontal; }
  .sidebar.collapsed { width:0 !important; min-width:0 !important; max-width:0 !important; padding:0; border:0; overflow:hidden; }
    .sidebar h3 { margin:6px 6px 10px; }
  .sidebar .node-item { display:flex; align-items:center; justify-content:space-between; padding:6px 6px; border-radius:12px; margin:4px 0; background:#0e1422; border:1px solid rgba(255,255,255,.06); gap:6px; }
  .sidebar .node-item input { flex: 1 1 auto; min-width: 0; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.12); background:#0a0f1a; color:#e5e7eb; }
    .sidebar .node-item button { padding:6px 10px; border-radius:8px; border:0; cursor:pointer; }
  .canvas { position:relative; background:#0a0f1a; border-radius:16px; overflow:auto; border:1px solid rgba(255,255,255,.06); /* Ocultar barras de scroll visibles */ -ms-overflow-style: none; scrollbar-width: none; }
  .canvas::-webkit-scrollbar { width:0; height:0; display:none; }
  /* Manijas laterales para colapsar/expandir sidebar */
  .side-handle { position:absolute; top:50%; transform: translateY(-50%); width:22px; height:56px; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:#0b1220; color:#e5e7eb; display:flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:0 6px 12px rgba(0,0,0,.18); z-index:1000; font-size:14px; opacity:.96; }
  .side-handle:hover { background:#111827; }
  /* Manija para colapsar: pegada al borde derecho del sidebar */
  .side-handle.collapse { right:6px; }
  /* Manija para expandir: pegada al borde izquierdo del canvas, visible solo cuando está colapsado */
  .side-handle.expand { position:fixed; left:8px; top:50%; transform: translateY(-50%); display:none; z-index:10000; }
  /* Failsafe: fuerza visibilidad pase lo que pase */
  .side-handle.expand.failsafe { display:flex !important; }
  .wrap.sidebar-collapsed .side-handle.expand { display:flex; }
  .wrap.sidebar-collapsed .sidebar .side-handle.collapse { display:none; }
  /* Fallback: si el sidebar está colapsado, muestra la manija de expandir aunque falle la clase en .wrap */
  .sidebar.collapsed ~ section.canvas .side-handle.expand { display:flex; }
    /* Contenedor de zoom */
    .stage { position:relative; width: 1200px; height: 800px; }
    .stage-inner { position:relative; transform-origin: 0 0; }
    /* Grid sutil de fondo (tema oscuro) */
    .stage-inner.grid-bg {
      background-image:
        linear-gradient(to right, rgba(148,163,184,.08) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(148,163,184,.08) 1px, transparent 1px);
      background-size: 20px 20px;
      background-position: 0 0;
    }
  .nodes { position:relative; padding:20px; min-width: 1200px; min-height: 800px; }
  .node { position:absolute; width: 340px; background:var(--card); border-radius:14px; padding:12px; box-shadow: 0 12px 28px rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.06); }
  .node.selected { outline: 3px solid #60a5fa; box-shadow: 0 12px 32px rgba(96,165,250,.35); }
  .node .head { display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px; }
    .node .head input[type="text"] { flex:1; font-weight:700; padding:10px 12px; border:1px solid rgba(255,255,255,.12); border-radius:12px; background:#0a0f1a; color:#e5e7eb; }
    .node .head .start { font-size:12px; color:#fff; background:#ff7a59; padding:2px 6px; border-radius:6px; }
  .node .head .drag { cursor:move; user-select:none; padding:2px 6px; color:#888; }
    .node textarea { width:100%; min-height: 90px; padding:10px 12px; border:1px solid rgba(255,255,255,.12); background:#0a0f1a; color:#e5e7eb; border-radius:12px; font-size:14px; }
    .btns { margin-top:6px; }
  .btns .row { display:grid; grid-template-columns: 1fr 26px auto; gap:8px; align-items:center; margin-bottom:8px; }
    .btns input, .btns select { padding:10px 12px; border:1px solid rgba(255,255,255,.12); background:#0a0f1a; color:#e5e7eb; border-radius:12px; }
  .btns .row .delbtn { width:28px; height:28px; display:inline-flex; align-items:center; justify-content:center; border-radius:999px; border:1px solid rgba(255,255,255,.16); background:#0b1220; color:#e5e7eb; cursor:pointer; line-height:1; font-size:16px; }
  .btns .row .delbtn:hover { background: linear-gradient(135deg,#f87171,#ef4444); color:#fff; border-color:transparent; }
  /* Botón "+ Añadir botón" sobrio */
  .btns .addRow { background:#0b1220; color:#cbd5e1; border:1px dashed rgba(255,255,255,.16); border-radius:8px; padding:8px 10px; cursor:pointer; font-weight:600; transition:background-color .15s ease, border-color .15s ease, color .15s ease, transform .15s ease; }
  .btns .addRow:hover { background:#111827; color:#e5e7eb; border-color:#9ca3af; }
  /* Igualar estilo de AddRow en botones de Adjuntos */
  .assets .actions .u-btn { background:#0b1220; color:#cbd5e1; border:1px dashed rgba(255,255,255,.16); border-radius:8px; padding:8px 10px; cursor:pointer; font-weight:600; transition:background-color .15s ease, border-color .15s ease, color .15s ease, transform .15s ease; }
  .assets .actions .u-btn:hover { background:#111827; color:#e5e7eb; border-color:#9ca3af; }
    .legend { font-size:12px; color:var(--muted); margin-top:4px; }
  svg.lines { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:2; }
  .nodes { position:relative; padding:20px; min-width: 1200px; min-height: 800px; z-index:1; }
    .edge { stroke:#8a8aa8; stroke-width:2; marker-end: url(#arrow); }
  /* Hacer clic directamente sobre el trazo para eliminar */
  svg.lines path { pointer-events: stroke; }
  .edge:hover { stroke:#7444a8; stroke-width:3; }
  /* Conectores más visibles */
  .connector { width:14px; height:14px; border-radius:50%; border:2px solid #7444a8; background:#0a0f1a; display:inline-block; margin:0 auto; box-shadow:0 0 0 2px rgba(124,58,237,.15), 0 2px 6px rgba(0,0,0,.35); position:relative; z-index:4; }
  .connector:hover { background:#e7dbff; }
  .connector:focus { outline:2px solid #60a5fa; outline-offset:2px; }
  .inlet { width:14px; height:14px; border-radius:50%; border:2px solid #8a8aa8; background:#0a0f1a; display:inline-block; margin-right:6px; box-shadow:0 0 0 2px rgba(148,163,184,.15), 0 2px 6px rgba(0,0,0,.35); position:relative; z-index:4; }
  .preview { stroke:#7444a8; stroke-width:2; fill:none; stroke-dasharray:4 4; }
  .edge.selected { stroke:#7444a8 !important; stroke-width:3 !important; }
  .start-connector { position:absolute; bottom:10px; right:10px; width:16px; height:16px; border-radius:50%; border:2px solid #7444a8; background:#0a0f1a; box-shadow:0 0 0 2px rgba(124,58,237,.15), 0 2px 6px rgba(0,0,0,.35); z-index:4; }
  .start-connector:hover { background:#e7dbff; }
  /* Conector de nodo acción (para flujos sin botones) */
  .node-connector { position:absolute; bottom:10px; right:10px; width:16px; height:16px; border-radius:50%; border:2px solid #7444a8; background:#0a0f1a; box-shadow:0 0 0 2px rgba(124,58,237,.15), 0 2px 6px rgba(0,0,0,.35); z-index:4; }
  .node-connector:hover { background:#e7dbff; }
  /* Badges flotantes (tipo y estado inicio) ubicadas con inteligencia en la esquina */
  .node .badges { position:absolute; top:-10px; right:10px; display:flex; gap:6px; z-index:5; }
  .node .badge { font-size:12px; line-height:1; padding:3px 8px; border-radius:999px; background:#6b7280; color:#fff; border:1px solid rgba(255,255,255,.18); box-shadow:0 4px 12px rgba(0,0,0,.25); white-space:nowrap; }
  .node .badge.type { background:#6c757d; }
  .node .badge.start { background:#ff7a59; }
  /* Assets UI (pro, sobrio) */
  .assets { background:transparent; border:1px solid rgba(255,255,255,.08); padding:10px; border-radius:12px; margin-top:10px; }
  .assets .title { display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; font-weight:700; }
  .assets .hint { font-size:12px; color:var(--muted); }
  .assets .dropzone { border:1px dashed rgba(148,163,184,.35); border-radius:10px; padding:10px; text-align:center; color:var(--muted); cursor:pointer; background:rgba(255,255,255,.02); }
  /* Hover de dropzone sin morado (neutro) */
  .assets .dropzone.hover { background:rgba(255,255,255,.05); border-color:rgba(148,163,184,.5); color:#e5e7eb; }
  .assets .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:8px; }
  .u-btn { padding:8px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.16); background:#0b1220; color:#e5e7eb; cursor:pointer; font-weight:600; }
  /* Estilo profesional: botones sobrios sin degradados */
  .u-btn.primary { background:#0b1220; color:#e5e7eb; border:1px solid rgba(255,255,255,.16); }
  .u-btn.primary:hover { background:#111827; border-color:#9ca3af; }
  .u-btn.ghost { background:transparent; color:#cbd5e1; border:1px dashed rgba(255,255,255,.18); }
  .u-btn.ghost:hover { background:#0c1220; color:#e5e7eb; border-color:#9ca3af; }
  .assets .list { display:flex; flex-direction:column; gap:6px; margin-top:8px; }
  .file-row { display:flex; align-items:center; gap:10px; padding:8px; border:1px solid rgba(255,255,255,.08); border-radius:10px; background:rgba(255,255,255,.02); }
  .file-row .thumb { width:36px; height:36px; border-radius:8px; background:#111827; display:flex; align-items:center; justify-content:center; font-size:18px; overflow:hidden; }
  .file-row .thumb img { width:100%; height:100%; object-fit:cover; }
  .file-row .name { flex:1; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .file-row .meta { font-size:12px; color:var(--muted); }
  .file-row .actions { display:flex; gap:6px; }
  .icon-btn { width:32px; height:32px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:#0b1220; color:#e5e7eb; cursor:pointer; }
  .icon-btn.view { background:#0b1220; }
  /* Minimalista: sin degradados para eliminar; acento rojo solo en hover */
  .icon-btn.del { background:#0b1220; color:#e5e7eb; border-color:rgba(255,255,255,.14); }
  .icon-btn.del:hover { color:#ef4444; border-color:#ef4444; }
  /* Zoom HUD */
  .zoom-hud { position:absolute; right:10px; bottom:10px; background:rgba(0,0,0,.6); color:#fff; padding:6px 8px; border-radius:8px; font-size:12px; z-index:3; border:1px solid rgba(255,255,255,.12); }
  /* Menú contextual para flechas */
  .edge-menu { position:fixed; z-index:10000; background:#fff; color:#0f172a; border:1px solid #e5e7eb; border-radius:10px; box-shadow:0 10px 24px rgba(0,0,0,.18); padding:6px; min-width:220px; display:none; }
  .edge-menu .item { display:flex; align-items:center; gap:8px; padding:8px 10px; border-radius:8px; cursor:pointer; }
  .edge-menu .item:hover { background:#f3f4f6; }
  .edge-menu .danger { color:#b91c1c; }
  .edge-menu .item svg { width:16px; height:16px; stroke: currentColor; fill:none; stroke-width:1.8; stroke-linecap:round; stroke-linejoin:round; }
    /* Toolbar flotante de nodo (tipo Chatfuel) */
    .node-toolbar { position:absolute; display:none; z-index:5; background:rgba(17,24,39,.9); border:1px solid rgba(255,255,255,.08); backdrop-filter: blur(6px); color:#fff; padding:6px; border-radius:12px; box-shadow:0 10px 24px rgba(0,0,0,.35); }
    .node-toolbar .group { display:flex; align-items:center; gap:6px; }
    .node-toolbar button { width:32px; height:32px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:#0b1220; color:#e5e7eb; cursor:pointer; }
    .node-toolbar button:hover { transform: translateY(-1px); }
  /* Toolbar de nodo minimalista (sin degradados) */
  .node-toolbar button { transition: background-color .15s ease, border-color .15s ease, color .15s ease, transform .15s ease; }
  .node-toolbar button svg { width:18px; height:18px; stroke: currentColor; fill: none; stroke-width: 1.8; stroke-linecap: round; stroke-linejoin: round; }
  .node-toolbar .act-dup { background:#0b1220; color:#e5e7eb; border-color:rgba(255,255,255,.14); }
  .node-toolbar .act-del { background:#0b1220; color:#e5e7eb; border-color:rgba(255,255,255,.14); }
  .node-toolbar .act-start { background:#0b1220; color:#e5e7eb; border-color:rgba(255,255,255,.14); }
  .node-toolbar .act-more { background:#111827; }
  .node-toolbar .act-dup:hover { border-color:#60a5fa; }
  .node-toolbar .act-del:hover { border-color:#ef4444; }
  .node-toolbar .act-start:hover { border-color:#22c55e; }
    /* triangulito decorativo */
    .node-toolbar:after { content:""; position:absolute; bottom:-6px; left:50%; transform:translateX(-50%); border-width:6px 6px 0 6px; border-style:solid; border-color:rgba(17,24,39,.9) transparent transparent transparent; }
    /* Overlay para elegir tipo de nodo */
    .overlay { position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:9999; }
    .overlay .panel { background:#0b1220; border:1px solid rgba(255,255,255,.08); color:#e2e8f0; border-radius:12px; padding:16px; width:360px; box-shadow:0 8px 28px rgba(0,0,0,.45); }
    .overlay .panel h4 { margin:0 0 10px; }
    .overlay .choices { display:flex; flex-direction:column; gap:8px; }
    .overlay .choices button { padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,.12); cursor:pointer; text-align:left; background:#0a0f1a; color:#e5e7eb; }
    .type-badge { font-size:12px; color:#fff; background:#6c757d; padding:2px 6px; border-radius:6px; margin-left:6px; }
    /* Overlay de preview */
  #previewOverlay .panel { width:auto; max-width:98vw; max-height:95vh; padding:0; overflow:hidden; display:flex; flex-direction:column; border-radius:12px; }
  #previewOverlay iframe { width:100%; height:100%; border:0; display:block; margin:0; background:#111827; }
  #previewOverlay .bar { display:flex; gap:8px; justify-content:space-between; align-items:center; padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.08); font-size:13px; }
  /* Fondo del overlay de vista previa (oscuro) para que resalte el marco del teléfono */
  #previewOverlay { background: rgba(0,0,0,.55) !important; backdrop-filter: none; }
  #previewOverlay .bar .left { font-weight:700; opacity:.9; }
  #previewOverlay .close-x { width:28px; height:28px; display:inline-flex; align-items:center; justify-content:center; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:#0b1220; color:#e5e7eb; cursor:pointer; line-height:1; font-size:16px; }
  #previewOverlay .close-x:hover { background:#ef4444; color:#fff; border-color:transparent; }
  /* (Se removieron controles de tamaño) */
  /* Marco tipo teléfono */
  #previewOverlay .body { flex:1; display:flex; align-items:center; justify-content:center; padding:10px; background:#f3f4f6; }
  #previewOverlay .device { position:relative; width:420px; height:auto; border-radius:18px; background:#000; box-shadow:0 6px 18px rgba(0,0,0,.32); border:1px solid rgba(255,255,255,.07); padding:6px; display:flex; }
  #previewOverlay .screen { border-radius:14px; overflow:hidden; background:#111827; width:100%; height:100%; display:flex; }
  #previewOverlay .notch { position:absolute; top:6px; left:50%; transform:translateX(-50%); width:96px; height:10px; background:#0a0a0a; border-radius:8px; box-shadow: inset 0 -2px 6px rgba(0,0,0,.35); }
  /* Controles de zoom (separados del HUD de porcentaje) */
  .zoom-controls { position:absolute; right:10px; bottom:46px; display:flex; gap:6px; z-index:3; }
  .zoom-controls button { padding:6px 8px; font-size:12px; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:#0b1220; color:#e5e7eb; cursor:pointer; }
  .zoom-controls button:hover { background:#111827; }
  /* Overlay de IA (formulario ancho) */
  #aiOverlay .panel { width:min(920px, 94vw); max-height:92vh; overflow:auto; }
  #aiOverlay .bar { display:flex; gap:8px; justify-content:space-between; align-items:center; padding:8px 10px; border-bottom:1px solid rgba(255,255,255,.08); font-size:13px; }
  #aiOverlay .close-x { width:28px; height:28px; display:inline-flex; align-items:center; justify-content:center; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:#0b1220; color:#e5e7eb; cursor:pointer; line-height:1; font-size:16px; }
  #aiOverlay .close-x:hover { background:#ef4444; color:#fff; border-color:transparent; }
  #aiOverlay .body { padding:12px; }
  #aiOverlay .grid { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
  #aiOverlay label { display:block; font-size:12px; color:#94a3b8; margin-bottom:4px; }
  #aiOverlay input, #aiOverlay textarea { width:100%; padding:10px 12px; border:1px solid rgba(255,255,255,.12); border-radius:10px; background:#0a0f1a; color:#e5e7eb; }
  #aiOverlay textarea { min-height:120px }
  #aiOverlay .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:10px }
  #aiOverlay h4 { margin:14px 0 8px; font-size:14px; font-weight:800; opacity:.9; }
  #aiOverlay .subtle { font-size:12px; color:#94a3b8; }
  #aiOverlay .row2 { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
  #aiOverlay .row3 { display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; }
  #aiOverlay .inline { display:flex; align-items:center; gap:8px; }
  </style>
  <style>
    /* Tema claro opcional */
    :root[data-theme="light"] { --bg:#f6f7fb; --card:#ffffff; --muted:#4b5563; --text:#111827; --primary:#7c3aed; --green:#16a34a; --red:#ef4444; --ink:#f3f4f6; }
    :root[data-theme="light"] body { background: var(--bg); color: var(--text); }
  /* En tema claro, contrastar header y sidebar con fondo oscuro para diferenciar del lienzo claro */
  :root[data-theme="light"] header { background:#0b1220; color:#e2e8f0; border-bottom:1px solid rgba(255,255,255,.06); }
  :root[data-theme="light"] .btn.minor { background:#f3f4f6; color:#111827; border-color:#e5e7eb; }
  :root[data-theme="light"] .sidebar { background:#0b1220; border-color:rgba(255,255,255,.06); }
  :root[data-theme="light"] .sidebar .node-item { background:#0e1422; border-color:rgba(255,255,255,.06); }
  :root[data-theme="light"] .sidebar .node-item input { background:#0a0f1a; color:#e5e7eb; border-color:rgba(255,255,255,.12); }
    :root[data-theme="light"] .canvas { background:#f3f4f6; border-color:#e5e7eb; }
    :root[data-theme="light"] .node { background:#ffffff; border-color:#e5e7eb; box-shadow:0 12px 28px rgba(0,0,0,.08); }
    :root[data-theme="light"] .node .head input[type="text"] { background:#ffffff; color:#111827; border-color:#e5e7eb; }
    :root[data-theme="light"] .node textarea { background:#ffffff; color:#111827; border-color:#e5e7eb; }
    :root[data-theme="light"] .btns input, :root[data-theme="light"] .btns select { background:#ffffff; color:#111827; border-color:#e5e7eb; }
  :root[data-theme="light"] .connector { background:#ffffff; border-color:#7c3aed; box-shadow:0 0 0 2px rgba(124,58,237,.15), 0 2px 6px rgba(0,0,0,.2); }
  :root[data-theme="light"] .inlet { background:#ffffff; border-color:#9ca3af; box-shadow:0 0 0 2px rgba(148,163,184,.15), 0 2px 6px rgba(0,0,0,.2); }
  :root[data-theme="light"] .start-connector, :root[data-theme="light"] .node-connector { background:#ffffff; border-color:#7c3aed; box-shadow:0 0 0 2px rgba(124,58,237,.15), 0 2px 6px rgba(0,0,0,.2); }
  :root[data-theme="light"] .node .badge { background:#e5e7eb; color:#111827; border-color:#cbd5e1; }
  :root[data-theme="light"] .assets { background:#f8f9ff; border-color:#d9ddff; }
  :root[data-theme="light"] .file-row { background:#ffffff; border-color:#e5e7eb; }
  :root[data-theme="light"] .file-row .name { color:#111827; }
  :root[data-theme="light"] .icon-btn { background:#f3f4f6; color:#111827; border-color:#e5e7eb; }
  :root[data-theme="light"] .assets .dropzone { background:#fafafa; border-color:#e5e7eb; }
    :root[data-theme="light"] .zoom-hud { background:rgba(0,0,0,.7); border-color:transparent; color:#fff; }
    :root[data-theme="light"] svg.lines .edge { stroke:#9ca3af; }
  :root[data-theme="light"] .btns .row .delbtn { background:#f3f4f6; color:#111827; border-color:#e5e7eb; }
  :root[data-theme="light"] .btns .row .delbtn:hover { background:#ef4444; color:#fff; border-color:transparent; }
    /* Botones de Adjuntos minimalistas (sin morado) */
    :root[data-theme="light"] .u-btn { background:#f8fafc; color:#111827; border:1px solid #e5e7eb; }
    :root[data-theme="light"] .u-btn:hover { background:#f3f4f6; border-color:#cbd5e1; }
    :root[data-theme="light"] .u-btn.primary { background:#f3f4f6; color:#111827; border:1px solid #cbd5e1; }
    :root[data-theme="light"] .u-btn.ghost { background:transparent; color:#374151; border:1px dashed #d1d5db; }
    :root[data-theme="light"] .u-btn.ghost:hover { background:#f9fafb; border-color:#cbd5e1; }
    :root[data-theme="light"] .node-toolbar { background:#ffffff; border-color:#e5e7eb; color:#111827; box-shadow:0 10px 24px rgba(0,0,0,.14); }
    :root[data-theme="light"] .node-toolbar:after { border-color:#ffffff transparent transparent transparent; }
    :root[data-theme="light"] .node-toolbar button { background:#f3f4f6; color:#111827; border-color:#e5e7eb; }
  :root[data-theme="light"] .node-toolbar .act-dup,
  :root[data-theme="light"] .node-toolbar .act-del,
  :root[data-theme="light"] .node-toolbar .act-start { background:#f3f4f6; color:#111827; border-color:#e5e7eb; }
  :root[data-theme="light"] .node-toolbar .act-dup:hover { border-color:#60a5fa; background:#eef2ff; }
  :root[data-theme="light"] .node-toolbar .act-del:hover { border-color:#ef4444; background:#fee2e2; }
  :root[data-theme="light"] .node-toolbar .act-start:hover { border-color:#22c55e; background:#dcfce7; }
    /* Tema claro: botón "+ Añadir botón" sobrio */
  :root[data-theme="light"] .btns .addRow { background:#f8fafc; color:#6b7280; border:1px dashed #d1d5db; transition:background-color .15s ease, border-color .15s ease, color .15s ease, transform .15s ease; }
  :root[data-theme="light"] .btns .addRow:hover { background:#f3f4f6; color:#374151; border-color:#cbd5e1; }
  /* Igualar estilo de AddRow en Adjuntos (tema claro) */
  :root[data-theme="light"] .assets .actions .u-btn { background:#f8fafc; color:#6b7280; border:1px dashed #d1d5db; border-radius:8px; padding:8px 10px; font-weight:600; transition:background-color .15s ease, border-color .15s ease, color .15s ease, transform .15s ease; }
  :root[data-theme="light"] .assets .actions .u-btn:hover { background:#f3f4f6; color:#374151; border-color:#cbd5e1; }
  /* Grid en tema claro (líneas más sutiles oscuras) */
  :root[data-theme="light"] .stage-inner.grid-bg {
    background-image:
      linear-gradient(to right, rgba(17,24,39,.06) 1px, transparent 1px),
      linear-gradient(to bottom, rgba(17,24,39,.06) 1px, transparent 1px);
  }
  :root[data-theme="light"] .zoom-controls button { background:#f3f4f6; color:#111827; border-color:#e5e7eb; }
  :root[data-theme="light"] .zoom-controls button:hover { background:#e5e7eb; }
  </style>
</head>
<body>
  <header>
  <div class="brand"><span class="dot"></span> <span class="brand-title">OptiChat • Builder</span> <span class="hdr-hint">(máx. 3 botones por nodo)</span> <span id="statusChip" class="status-chip off">Inactivo</span></div>
    <div class="actions">
  <!-- Botón del header para sidebar eliminado por diseño minimal -->
      <a class="btn minor" href="/panel/bots/{{ bot_id }}/flows/">← Volver a Flujos</a>
      <button id="themeBtn" class="btn minor" type="button" title="Cambiar tema">Tema: Oscuro</button>
  <button class="btn minor" onclick="openAIConfig()">🧠 Cerebro de IA</button>
  <button class="btn reload" onclick="openPreview()">👀 Vista previa</button>
      <button class="btn reload" onclick="reloadFromServer()">↻ Recargar</button>
      <button class="btn save" onclick="saveFlow()">💾 Guardar</button>
    </div>
  </header>

  <div class="wrap">
    <aside class="sidebar">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
        <div style="display:flex; align-items:center; gap:6px;">
          <h3 style="margin:0;">Nodos</h3>
        </div>
        <button class="btn add" onclick="openAddNodeMenu()">+ Añadir nodo</button>
      </div>
      <!-- Manija para colapsar (hija directa del sidebar, anclada al panel completo) -->
      <button id="collapseHandle" class="side-handle collapse" title="Ocultar panel" aria-label="Ocultar panel">«</button>
      <div style="margin-top:8px; display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="flowEnabledToggle" />
        <label for="flowEnabledToggle" style="font-size:13px; color:var(--muted)">Flujo activo</label>
      </div>
      <div style="margin-top:8px;">
        <label style="font-size:12px; color:var(--muted)">Nodo inicial</label>
        <select id="startNode" style="width:100%; padding:6px 8px; border:1px solid #ddd; border-radius:8px;"></select>
      </div>
      <div id="nodeList" style="margin-top:10px;"></div>
      <p class="legend">Tips:
        <br>• Arrastra el circulito hacia otra caja para conectar ese botón.
        <br>• Las flechas aparecen solo cuando el botón está conectado a otro nodo.
        <br>• Haz clic sobre una flecha para eliminar esa conexión.
      </p>
    </aside>

    <section class="canvas">
      <div class="stage" id="stage">
  <div class="stage-inner grid-bg" id="stageInner">
          <svg class="lines"></svg>
          <div class="nodes" id="nodes"></div>
        </div>
      </div>
      <!-- Toolbar flotante (se posiciona sobre el nodo seleccionado) -->
      <div id="nodeToolbar" class="node-toolbar" role="toolbar" aria-label="Acciones de nodo">
        <div class="group">
          <button type="button" class="act-dup" title="Duplicar" aria-label="Duplicar" data-action="dup">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <rect x="9" y="9" width="10" height="10" rx="2"></rect>
              <rect x="5" y="5" width="10" height="10" rx="2"></rect>
            </svg>
          </button>
          <button type="button" class="act-start" title="Marcar como inicio" aria-label="Marcar como inicio" data-action="start">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12 17.27 18.18 21 16.54 13.97 22 9.24 14.81 8.63 12 2 9.19 8.63 2 9.24 7.46 13.97 5.82 21 12 17.27z"></path>
            </svg>
          </button>
          <button type="button" class="act-del" title="Eliminar" aria-label="Eliminar" data-action="del">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M3 6h18"></path>
              <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
              <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
              <path d="M10 11v6M14 11v6"></path>
            </svg>
          </button>
          <button type="button" class="act-more" title="Más" data-action="more">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <circle cx="12" cy="12" r="1.8"></circle>
              <circle cx="6" cy="12" r="1.8"></circle>
              <circle cx="18" cy="12" r="1.8"></circle>
            </svg>
          </button>
        </div>
      </div>
  <!-- Manija para expandir (sobre el canvas, visible cuando está colapsado) -->
  <button id="expandHandle" class="side-handle expand" title="Mostrar panel" aria-label="Mostrar panel">»</button>
  <div class="zoom-controls">
    <button type="button" id="fitBtn" title="Ajustar a pantalla">Ajustar</button>
  </div>
  <div class="zoom-hud" id="zoomHud">100% (rueda: zoom, rueda presionada o Space: mover)</div>
    </section>
  </div>

  <form id="saveForm" method="post" action="/flow?key={{ flow_key }}" style="display:none;">
    <input type="hidden" name="content" id="contentField" />
  </form>

  <div id="toast" style="position:fixed; left:50%; transform:translateX(-50%); bottom:20px; background:#1e7e34; color:#fff; padding:10px 14px; border-radius:10px; box-shadow:0 6px 16px rgba(0,0,0,.2); font-weight:600; display:none; z-index:10000;">
    ✅ Flujo guardado correctamente.
  </div>

  <div id="overlay" class="overlay">
    <div class="panel">
      <h4>Nuevo nodo</h4>
      <div class="choices">
        <button onclick="addNodeOfType('action')">Acción (mensaje + botones)</button>
        <button onclick="addNodeOfType('advisor')">Conversar con asesor (número WhatsApp)</button>
        <button onclick="addNodeOfType('trigger')">Trigger (keywords / deeplink / IA)</button>
      </div>
      <div style="text-align:right; margin-top:10px;"><button class="btn del" onclick="closeAddNodeMenu()">Cerrar</button></div>
    </div>
  </div>

  <!-- Overlay de vista previa (iframe, sin salir de la pestaña) -->
  <div id="previewOverlay" class="overlay" style="display:none;">
    <div class="panel">
      <div class="bar">
        <div class="left">Vista previa</div>
        <button class="close-x" onclick="closePreview()" aria-label="Cerrar">×</button>
      </div>
      <div class="body">
        <div class="device">
          <div class="notch"></div>
          <div class="screen">
            <iframe id="previewFrame" src="about:blank" title="Vista previa"></iframe>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Overlay de configuración de IA -->
  <div id="aiOverlay" class="overlay" style="display:none;">
    <div class="panel">
      <div class="bar">
        <div class="left" style="font-weight:800">Cerebro de IA</div>
        <button class="close-x" onclick="closeAIConfig()" aria-label="Cerrar">×</button>
      </div>
      <div class="body">
        <div class="grid">
          <div>
            <label>Nombre del asistente</label>
            <input id="ai_name" type="text" placeholder="Ej. OptiChat Asistente" />
          </div>
          <div>
            <label>Lenguaje</label>
            <input id="ai_lang" type="text" placeholder="Ej. es-PE" />
          </div>
          <div>
            <label>URL del sitio web</label>
            <input id="ai_site" type="url" placeholder="https://tu-dominio.com" />
          </div>
          <div>
            <label>Número de teléfono</label>
            <input id="ai_phone" type="text" placeholder="+51 999 999 999" />
          </div>
          <div style="grid-column:1 / span 2">
            <label>Correo electrónico</label>
            <input id="ai_email" type="email" placeholder="soporte@tu-dominio.com" />
          </div>
          <div style="grid-column:1 / span 2">
            <label>Información obligatoria al hacer un pedido (una por línea)</label>
            <textarea id="ai_required" placeholder="Nombre y apellidos
DNI
Dirección completa
Producto o SKU
Cantidad
Variante (talla/color)
Método de pago
Correo y teléfono de contacto"></textarea>
          </div>
          <div style="grid-column:1 / span 2">
            <label>Temas fuera de alcance (una por línea, opcional)</label>
            <textarea id="ai_oos" placeholder="Soporte técnico hardware
Asesoría legal"></textarea>
          </div>
          <div style="grid-column:1 / span 2">
            <label>Políticas de respuesta (una por línea, opcional)</label>
            <textarea id="ai_policies" placeholder="No inventar importes
Usar moneda PEN
No prometer plazos sin fuente"></textarea>
          </div>
          <div style="grid-column:1 / span 2">
            <label>Políticas de comunicación (recomendado)</label>
            <div class="inline"><input type="checkbox" id="pol_no_invent" /> <span class="subtle">No inventar información; si falta, pedirla o derivar a humano</span></div>
            <div class="inline" style="margin-top:6px;"><input type="checkbox" id="pol_no_swear" /> <span class="subtle">No usar ni responder con groserías o lenguaje ofensivo</span></div>
          </div>
        </div>

        <h4>Perfil del negocio</h4>
        <div class="grid">
          <div>
            <label>Nombre comercial</label>
            <input id="biz_name" type="text" placeholder="Ej. Tienda OptiChat" />
          </div>
          <div>
            <label>Razón social (opcional)</label>
            <input id="biz_legal_name" type="text" placeholder="Ej. OptiChat SAC" />
          </div>
          <div>
            <label>RUC (opcional)</label>
            <input id="biz_ruc" type="text" placeholder="Ej. 2060xxxxxxx" />
          </div>
          <div>
            <label>Zona horaria</label>
            <input id="biz_tz" type="text" placeholder="Ej. America/Lima" />
          </div>
        </div>

        <h4>Ubicación y horarios</h4>
        <div class="grid">
          <div>
            <label>Dirección</label>
            <input id="biz_addr" type="text" placeholder="Calle 123, Distrito" />
          </div>
          <div>
            <label>Ciudad</label>
            <input id="biz_city" type="text" placeholder="Lima" />
          </div>
          <div>
            <label>Región/Departamento</label>
            <input id="biz_region" type="text" placeholder="Lima" />
          </div>
          <div>
            <label>País</label>
            <input id="biz_country" type="text" placeholder="Perú" />
          </div>
          <div>
            <label>URL de Google Maps</label>
            <input id="biz_maps" type="url" placeholder="https://maps.google.com/..." />
          </div>
          <div>
            <label>Ubigeo (opcional)</label>
            <input id="biz_ubigeo" type="text" placeholder="Ej. 150101" />
          </div>
          <div>
            <label>Horario L-V</label>
            <input id="biz_hours_week" type="text" placeholder="9:00 - 18:00" />
          </div>
          <div>
            <label>Horario Sábado</label>
            <input id="biz_hours_sat" type="text" placeholder="10:00 - 14:00" />
          </div>
          <div>
            <label>Horario Domingo/Feriados</label>
            <input id="biz_hours_sun" type="text" placeholder="Cerrado" />
          </div>
        </div>

        <h4>Redes sociales y canales</h4>
        <div class="grid">
          <div>
            <label>Instagram</label>
            <input id="soc_ig" type="url" placeholder="https://instagram.com/tu_cuenta" />
          </div>
          <div>
            <label>Facebook</label>
            <input id="soc_fb" type="url" placeholder="https://facebook.com/tu_pagina" />
          </div>
          <div>
            <label>TikTok</label>
            <input id="soc_tt" type="url" placeholder="https://tiktok.com/@tu_cuenta" />
          </div>
          <div>
            <label>YouTube</label>
            <input id="soc_yt" type="url" placeholder="https://youtube.com/@tu_canal" />
          </div>
          <div>
            <label>X (Twitter)</label>
            <input id="soc_x" type="url" placeholder="https://x.com/tu_cuenta" />
          </div>
          <div>
            <label>LinkTree (opcional)</label>
            <input id="soc_lt" type="url" placeholder="https://linktr.ee/tu_cuenta" />
          </div>
          <div style="grid-column:1 / span 2">
            <label>Enlace directo a WhatsApp</label>
            <input id="soc_wa" type="url" placeholder="https://wa.me/51XXXXXXXXX?text=Hola" />
          </div>
          <div style="grid-column:1 / span 2">
            <label>Sitio web (catálogo/tienda)</label>
            <input id="soc_web" type="url" placeholder="https://tu-dominio.com/tienda" />
          </div>
        </div>

        <h4>Modalidad de venta</h4>
        <div class="grid">
          <div>
            <label>Venta por menor (Sí/No)</label>
            <input id="sales_retail" type="text" placeholder="Sí/No" />
          </div>
          <div>
            <label>Venta por mayor (Sí/No)</label>
            <input id="sales_wholesale" type="text" placeholder="Sí/No" />
          </div>
          <div>
            <label>Pedido mínimo mayorista (unidades)</label>
            <input id="sales_wh_min" type="text" placeholder="Ej. 12" />
          </div>
          <div>
            <label>Lista de precios mayorista (URL)</label>
            <input id="sales_wh_price_list" type="url" placeholder="https://..." />
          </div>
          <div>
            <label>Mayorista requiere RUC (Sí/No)</label>
            <input id="sales_wh_requires_ruc" type="text" placeholder="Sí/No" />
          </div>
          <div>
            <label>Tiempo de preparación (pedidos grandes)</label>
            <input id="sales_wh_prep" type="text" placeholder="Ej. 2-4 días hábiles" />
          </div>
          <div style="grid-column:1 / span 2">
            <label>Descuentos por volumen (una por línea: Desde unidades; %)</label>
            <textarea id="sales_wh_discounts" placeholder="12; 5%
24; 10%
50; 15%"></textarea>
          </div>
        </div>

        <h4>Métodos de pago</h4>
        <div class="grid">
          <div>
            <label>Yape — Número</label>
            <input id="pay_yape_phone" type="text" placeholder="Número Yape (ej. 999999999)" />
          </div>
          <div>
            <label>Yape — Titular</label>
            <input id="pay_yape_holder" type="text" placeholder="Nombre del titular" />
          </div>
          <div>
            <label>Yape — Alias/Usuario (opcional)</label>
            <input id="pay_yape_alias" type="text" placeholder="Alias si aplica" />
          </div>
          <div>
            <label>Yape — QR (URL opcional)</label>
            <input id="pay_yape_qr" type="url" placeholder="https://.../yape-qr.png" />
          </div>

          <div>
            <label>Plin — Número</label>
            <input id="pay_plin_phone" type="text" placeholder="Número Plin (ej. 999999999)" />
          </div>
          <div>
            <label>Plin — Titular</label>
            <input id="pay_plin_holder" type="text" placeholder="Nombre del titular" />
          </div>
          <div>
            <label>Plin — QR (URL opcional)</label>
            <input id="pay_plin_qr" type="url" placeholder="https://.../plin-qr.png" />
          </div>
          <div>
            <label>Tarjeta — Marcas aceptadas</label>
            <input id="pay_card_brands" type="text" placeholder="Visa, MasterCard, Amex" />
          </div>
          <div>
            <label>Tarjeta — Proveedor/Plataforma</label>
            <input id="pay_card_provider" type="text" placeholder="Izipay, Culqi, MercadoPago" />
          </div>
          <div>
            <label>Tarjeta — Link de pago (opcional)</label>
            <input id="pay_card_link" type="url" placeholder="https://..." />
          </div>
          <div>
            <label>Tarjeta — Recargo/Notas (opcional)</label>
            <input id="pay_card_notes" type="text" placeholder="Sin recargo / +5%" />
          </div>

          <div style="grid-column:1 / span 2">
            <label>Transferencia bancaria — Cuentas (una por línea: Banco; N° Cuenta; CCI; Titular; Doc)</label>
            <textarea id="pay_tf_banks" placeholder="BCP; 123-4567890-0-12; 002-123-000456789012-34; Juan Pérez; DNI 12345678
BBVA; 0011-1234567890; 011-123-000123456789-01; OptiChat SAC; RUC 2060xxxxxxx"></textarea>
          </div>
          <div style="grid-column:1 / span 2">
            <label>Transferencia — Instrucciones (opcional)</label>
            <input id="pay_tf_instr" type="text" placeholder="Enviar voucher por WhatsApp para confirmar" />
          </div>
          <div>
            <label>Contraentrega (Sí/No)</label>
            <input id="pay_cod" type="text" placeholder="Sí en Lima / No en provincias" />
          </div>
        </div>

        <h4>Envíos y cobertura</h4>
        <div class="grid">
          <div style="grid-column:1 / span 2">
            <label>Distritos y costos (una por línea: Distrito; Precio; Tiempo)</label>
            <textarea id="ship_districts" placeholder="Miraflores; S/ 10; 24-48h
San Isidro; S/ 12; 24-48h
Callao; S/ 15; 48-72h"></textarea>
          </div>
          <div>
            <label>Tiempo típico de entrega</label>
            <input id="ship_eta" type="text" placeholder="Lima 24-48h / Provincias 3-5 días" />
          </div>
          <div>
            <label>Envío gratis desde (opcional)</label>
            <input id="ship_free" type="text" placeholder=">= S/ 150" />
          </div>
          <div>
            <label>Retiro en tienda (dirección si aplica)</label>
            <input id="ship_pickup" type="text" placeholder="Calle 123, Distrito (previa coordinación)" />
          </div>
          <div>
            <label>Socios de delivery (opcional)</label>
            <input id="ship_partners" type="text" placeholder="Moto propia, Rappi, PedidosYa" />
          </div>
        </div>

        <h4>Políticas y comprobantes</h4>
        <div class="grid">
          <div>
            <label>Política de cambios/devoluciones</label>
            <input id="pol_returns" type="text" placeholder="Cambios en 7 días con boleta" />
          </div>
          <div>
            <label>Garantía</label>
            <input id="pol_warranty" type="text" placeholder="Garantía 6 meses fabricante" />
          </div>
          <div>
            <label>Enlace a Términos</label>
            <input id="pol_terms" type="url" placeholder="https://.../terminos" />
          </div>
          <div>
            <label>Enlace a Privacidad</label>
            <input id="pol_privacy" type="url" placeholder="https://.../privacidad" />
          </div>
          <div>
            <label>Emite boleta</label>
            <input id="pol_boleta" type="text" placeholder="Sí/No" />
          </div>
          <div>
            <label>Emite factura</label>
            <input id="pol_factura" type="text" placeholder="Sí/No" />
          </div>
        </div>

        <div class="actions">
          <button class="btn minor" type="button" onclick="importAIFromFlow()">Leer del flujo</button>
          <button class="btn" type="button" onclick="applyAIToFlow(); showToast('Perfil de IA aplicado');">Aplicar</button>
          <button class="btn save" type="button" onclick="applyAIToFlow(); saveFlow(); closeAIConfig();">Aplicar y Guardar</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const FLOW_LIMIT = 3;
  let flow = JSON.parse('{{ flow_json|escapejs }}');
  const UPLOAD_MAX_MB = parseInt('{{ upload_max_mb|default:10 }}', 10);
  if (!flow || typeof flow !== 'object') flow = { start_node: null, nodes: {} };
    // Defaults para links: sin valores del entorno; el usuario define todo en el panel
    const DEFAULT_LINKS = { web: "", fb: "", ig: "", tiktok: "" };

  const nodesEl = document.getElementById('nodes');
    const linesSvg = document.querySelector('svg.lines');
    const canvasEl = document.querySelector('.canvas');
    const stageEl = document.getElementById('stage');
    const stageInner = document.getElementById('stageInner');
    const zoomHud = document.getElementById('zoomHud');
    const startNodeSel = document.getElementById('startNode');
    const nodeListEl = document.getElementById('nodeList');
  let dragging = null; // { id, el, dx, dy }
  const overlay = document.getElementById('overlay');
  let ZOOM = 1.0; const MIN_ZOOM=0.3, MAX_ZOOM=2.0;
  // Lienzo "infinito": padding virtual alrededor del mundo
  const WORLD_PAD = 5000;

    function uid(base){
      let n = 1; let id = base || 'node';
      while(flow.nodes[id]) { id = (base||'node') + '_' + (++n); }
      return id;
    }

    function ensureDefaults(){
      if (typeof flow.enabled !== 'boolean') flow.enabled = true;
      if (!flow.nodes) flow.nodes = {};
      // No crear nodos automáticos; todo se arma desde el panel
      flow.start_node = flow.start_node || Object.keys(flow.nodes)[0] || null;
      for (const k of Object.keys(flow.nodes)) {
        flow.nodes[k].text = flow.nodes[k].text || '';
        flow.nodes[k].buttons = (flow.nodes[k].buttons || []).slice(0, FLOW_LIMIT);
        flow.nodes[k].type = flow.nodes[k].type || 'action';
      }
    }
  updateStatusChip();
    function renderAll(){
      ensureDefaults();
      
      // Sidebar list
      startNodeSel.innerHTML = '';
      Object.keys(flow.nodes).forEach(id => {
        const opt = document.createElement('option');
        opt.value = id; opt.textContent = id; startNodeSel.appendChild(opt);
      });
      startNodeSel.value = flow.start_node || '';

      nodeListEl.innerHTML = '';
      Object.keys(flow.nodes).forEach(id => nodeListEl.appendChild(renderNodeListItem(id)));

      // Toggle de flujo activo
      const flowToggle = document.getElementById('flowEnabledToggle');
      if (flowToggle) {
        flowToggle.checked = !!flow.enabled;
        flowToggle.onchange = () => { flow.enabled = !!flowToggle.checked; updateStatusChip(); };
      }

      // Canvas nodes
      nodesEl.innerHTML = '';
  let i=0;
      const cols = 3; const gapX=360, gapY=220; // simple auto-grid
      Object.entries(flow.nodes).forEach(([id, node]) => {
        // Si el nodo no tiene posición, asignar una por grilla y guardarla
        if (!node.pos || typeof node.pos.x !== 'number' || typeof node.pos.y !== 'number') {
          const x = (i % cols) * gapX + 40;
          const y = Math.floor(i / cols) * gapY + 40;
          node.pos = { x, y };
        }
        nodesEl.appendChild(renderNodeCard(id, node, node.pos.x, node.pos.y));
        i++;
      });

      updateStageSize();
      drawEdges();
      window.setTimeout(drawEdges, 50);
    }

  function renderNodeListItem(id){
  const wrap = document.createElement('div');
      wrap.className = 'node-item';
      const inp = document.createElement('input');
      inp.value = id; inp.title = 'ID del nodo';
      inp.addEventListener('change', () => renameNode(id, inp.value.trim()));
  const del = document.createElement('button');
  del.className='icon-btn'; del.title='Eliminar'; del.setAttribute('aria-label','Eliminar');
  del.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true" style="width:16px;height:16px;stroke:currentColor;fill:none;stroke-width:1.8;stroke-linecap:round;stroke-linejoin:round;"><path d="M3 6h18"></path><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path><path d="M10 11v6M14 11v6"></path></svg>';
  del.onclick = () => { deleteNode(id); };
      wrap.appendChild(inp); wrap.appendChild(del);
      return wrap;
    }

    function renderNodeCard(id, node, x, y){
  const el = document.createElement('div');
      el.className = 'node'; el.style.left = x+'px'; el.style.top = y+'px';
      el.dataset.nodeId = id;
      el.innerHTML = '';

      const head = document.createElement('div'); head.className='head';
      const drag = document.createElement('span'); drag.className='drag'; drag.textContent='⠿'; drag.title='Arrastra para mover';
      head.appendChild(drag);
  const title = document.createElement('input'); title.type='text'; title.value = id; title.title='ID del nodo';
      title.addEventListener('change', () => renameNode(id, title.value.trim()));
  const inlet = document.createElement('span'); inlet.className='inlet'; inlet.title='Entrada de conexiones';
  head.appendChild(inlet);
  head.appendChild(title);
      // Badges flotantes (tipo e inicio) posicionadas fuera del cuadro con buen espaciado
      const badges = document.createElement('div'); badges.className='badges';
      const typeBadge = document.createElement('span'); typeBadge.className='badge type'; typeBadge.textContent=(node.type||'action');
      badges.appendChild(typeBadge);
      if (flow.start_node === id) {
        const startBadge = document.createElement('span'); startBadge.textContent='inicio'; startBadge.className='badge start';
        badges.appendChild(startBadge);
      }
      el.appendChild(badges);
      el.appendChild(head);

      // Cuerpo según tipo de nodo
      if ((node.type||'action') === 'advisor') {
        const phone = document.createElement('input'); phone.placeholder='+51xxxxxxxxx (solo dígitos o con +)'; phone.value = node.phone||'';
        phone.style.width = '100%'; phone.style.marginBottom = '6px';
        phone.oninput = () => { flow.nodes[id].phone = phone.value.trim(); };
        el.appendChild(phone);
  const ta = document.createElement('textarea'); ta.value = node.text || 'Te estamos transfiriendo con una asesora humana. Un momento por favor.';
        ta.placeholder = 'Texto opcional que se enviará'; ta.addEventListener('input', () => { flow.nodes[id].text = ta.value; });
        el.appendChild(ta);
  // Timeout de inactividad (minutos)
  const trow = document.createElement('div'); trow.style.display='grid'; trow.style.gridTemplateColumns='1fr 100px'; trow.style.gap='8px'; trow.style.alignItems='center'; trow.style.margin='6px 0';
  const tlab = document.createElement('label'); tlab.textContent = 'Cerrar por inactividad (min)'; tlab.style.fontSize='13px'; tlab.style.color='#333';
  const tnum = document.createElement('input'); tnum.type='number'; tnum.min='1'; tnum.max='720'; tnum.value = (node.timeout_min||node.human_timeout_min||15);
  tnum.oninput = ()=>{ const v = parseInt(tnum.value||'15',10); flow.nodes[id].timeout_min = isNaN(v)?15:Math.max(1, Math.min(720, v)); };
  trow.appendChild(tlab); trow.appendChild(tnum); el.appendChild(trow);
        // Links configurables (web y redes) con switches y URLs
        const linksBox = document.createElement('div'); linksBox.className='assets';
        const title = document.createElement('div'); title.style.fontWeight='700'; title.style.marginBottom='6px'; title.textContent='Links a mostrar mientras espera';
        linksBox.appendChild(title);
        const list = document.createElement('div'); list.style.display='flex'; list.style.flexDirection='column'; list.style.gap='6px';
        // Inicializar links del nodo si no existen
        const initIfNeeded = () => {
          if (!flow.nodes[id].links) {
            flow.nodes[id].links = {
              web: { enabled: false, url: '' },
              fb: { enabled: false, url: '' },
              ig: { enabled: false, url: '' },
              tiktok: { enabled: false, url: '' },
            };
            if (typeof flow.nodes[id].include_links === 'boolean') {
              const on = !!flow.nodes[id].include_links;
              Object.keys(flow.nodes[id].links).forEach(k => flow.nodes[id].links[k].enabled = on && !!flow.nodes[id].links[k].url);
            }
          }
        };
        initIfNeeded();

        const mkRow = (key, label) => {
          const row = document.createElement('div'); row.style.display='grid'; row.style.gridTemplateColumns='22px 1fr'; row.style.gap='8px'; row.style.alignItems='center';
          const chk = document.createElement('input'); chk.type='checkbox'; chk.checked = !!(flow.nodes[id].links?.[key]?.enabled);
          chk.onchange = () => { if (!flow.nodes[id].links) flow.nodes[id].links={}; if (!flow.nodes[id].links[key]) flow.nodes[id].links[key]={}; flow.nodes[id].links[key].enabled = !!chk.checked; syncIncludeLinks(); };
          const url = document.createElement('input'); url.placeholder = label + ' URL'; url.value = (flow.nodes[id].links?.[key]?.url || ''); url.style.width='100%';
          url.oninput = () => { if (!flow.nodes[id].links) flow.nodes[id].links={}; if (!flow.nodes[id].links[key]) flow.nodes[id].links[key]={}; flow.nodes[id].links[key].url = url.value.trim(); };
          row.appendChild(chk); row.appendChild(url);
          return row;
        };
        const syncIncludeLinks = () => {
          const l = flow.nodes[id].links || {};
          const anyOn = ['web','fb','ig','tiktok'].some(k => !!(l[k]?.enabled));
          flow.nodes[id].include_links = anyOn;
        };
        list.appendChild(mkRow('web', 'Web'));
        list.appendChild(mkRow('fb', 'Facebook'));
        list.appendChild(mkRow('ig', 'Instagram'));
        list.appendChild(mkRow('tiktok', 'TikTok'));
        const hint = document.createElement('div'); hint.className='legend'; hint.textContent='Activa/desactiva y edita las URLs que quieras mostrar.';
        linksBox.appendChild(list); linksBox.appendChild(hint);
        el.appendChild(linksBox);
      } else if ((node.type||'action') === 'trigger') {
        // Config UI para trigger
        const row = document.createElement('div'); row.style.display='grid'; row.style.gridTemplateColumns='1fr 1fr'; row.style.gap='8px'; row.style.margin='6px 0';
        const lab = document.createElement('label'); lab.textContent='Tipo de trigger'; lab.style.fontSize='13px'; lab.style.color='#333';
        const enabledWrap = document.createElement('div'); enabledWrap.style.display='flex'; enabledWrap.style.alignItems='center'; enabledWrap.style.gap='6px';
        const en = document.createElement('input'); en.type='checkbox'; en.checked = (typeof node.enabled==='boolean') ? !!node.enabled : true;
        en.onchange = ()=>{ flow.nodes[id].enabled = !!en.checked; };
        const enLab = document.createElement('label'); enLab.textContent='Activo'; enLab.style.fontSize='13px'; enLab.style.color='#333';
        enabledWrap.appendChild(en); enabledWrap.appendChild(enLab);
        const sel = document.createElement('select');
        ;['keywords','deeplink','ai'].forEach(t=>{ const o=document.createElement('option'); o.value=t; o.textContent=t; sel.appendChild(o); });
        sel.value = node.trigger_type || 'keywords';
        sel.onchange = ()=>{ flow.nodes[id].trigger_type = sel.value; refresh(); };
        row.appendChild(lab); row.appendChild(sel); el.appendChild(row);
        el.appendChild(enabledWrap);
        if ((node.trigger_type||'keywords') === 'keywords') {
          const kw = document.createElement('input'); kw.placeholder='Palabras clave separadas por coma'; kw.value = node.patterns||'';
          kw.style.width='100%'; kw.oninput = ()=>{ flow.nodes[id].patterns = kw.value; }; el.appendChild(kw);
        } else if ((node.trigger_type||'keywords') === 'deeplink') {
          const ex = document.createElement('textarea'); ex.placeholder='Frases exactas (una por línea) — para wa.me?text=...'; ex.value = node.patterns||''; ex.style.minHeight='60px';
          ex.addEventListener('input', ()=>{ flow.nodes[id].patterns = ex.value; }); el.appendChild(ex);
        } else if ((node.trigger_type||'keywords') === 'ai') {
          const hint = document.createElement('div'); hint.className='legend'; hint.textContent='La IA decidirá si arranca (ej: saludos/consulta general).'; el.appendChild(hint);
          const ins = document.createElement('textarea'); ins.placeholder='Instrucción opcional a la IA (ej: inicia si parece saludo)';
          ins.value = node.instruction||''; ins.style.minHeight='60px'; ins.addEventListener('input', ()=>{ flow.nodes[id].instruction = ins.value; }); el.appendChild(ins);
        }
      } else {
        const ta = document.createElement('textarea'); ta.value = node.text || '';
        ta.placeholder = 'Texto del mensaje'; ta.addEventListener('input', () => { flow.nodes[id].text = ta.value; });
        el.appendChild(ta);

        // Assets UI (pro): subir/arrastrar/URL manual
        const assetsBox = document.createElement('div'); assetsBox.className='assets';
        const header = document.createElement('div'); header.className='title';
        header.innerHTML = '<span>Adjuntos</span><span class="hint">Imágenes o PDFs (máx '+UPLOAD_MAX_MB+'MB)</span>';
        assetsBox.appendChild(header);
        const drop = document.createElement('div'); drop.className='dropzone'; drop.textContent = 'Suelta archivos aquí o haz clic para seleccionar';
        assetsBox.appendChild(drop);
        const actions = document.createElement('div'); actions.className='actions';
        const pickBtn = document.createElement('button'); pickBtn.className='u-btn primary'; pickBtn.textContent='Seleccionar archivos';
        const urlBtn = document.createElement('button'); urlBtn.className='u-btn ghost'; urlBtn.textContent='Agregar URL';
        actions.appendChild(urlBtn); actions.appendChild(pickBtn);
        assetsBox.appendChild(actions);
        const list = document.createElement('div'); list.className='list'; assetsBox.appendChild(list);

        const ensureArr = () => { if (!Array.isArray(flow.nodes[id].assets)) flow.nodes[id].assets = []; };
        function humanSize(bytes){ if (!bytes) return ''; const kb=bytes/1024, mb=kb/1024; return mb>=1? (mb.toFixed(1)+' MB') : (Math.max(1,Math.round(kb))+' KB'); }
        function isImageUrl(u){ const s=(u||'').toLowerCase(); return s.endsWith('.jpg')||s.endsWith('.jpeg')||s.endsWith('.png')||s.endsWith('.webp'); }

        const refreshList = () => {
          list.innerHTML='';
          (flow.nodes[id].assets||[]).forEach((a, idx) => {
            const row = document.createElement('div'); row.className='file-row';
            const th = document.createElement('div'); th.className='thumb';
            if ((a.type||'')==='image' || isImageUrl(a.url||'')) {
              const img = document.createElement('img'); img.src = a.url; img.alt=a.name||'img'; th.appendChild(img);
            } else { th.textContent = '📄'; }
            const nm = document.createElement('div'); nm.className='name'; nm.textContent = a.name || a.url || 'archivo';
            const meta = document.createElement('div'); meta.className='meta'; meta.textContent = a.size ? humanSize(a.size) : '';
            const acts = document.createElement('div'); acts.className='actions';
            const view = document.createElement('button'); view.className='icon-btn view'; view.title='Abrir'; view.textContent='↗';
            view.onclick = (ev)=>{ ev.preventDefault(); window.open(a.url, '_blank'); };
            const del = document.createElement('button'); del.className='icon-btn del'; del.title='Quitar'; del.setAttribute('aria-label','Quitar');
            del.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true" style="width:16px;height:16px;stroke:currentColor;fill:none;stroke-width:1.8;stroke-linecap:round;stroke-linejoin:round;"><path d="M3 6h18"></path><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path><path d="M10 11v6M14 11v6"></path></svg>';
            del.onclick = (ev)=>{ ev.preventDefault(); flow.nodes[id].assets.splice(idx,1); refreshList(); };
            acts.appendChild(view); acts.appendChild(del);
            row.appendChild(th); row.appendChild(nm); row.appendChild(meta); row.appendChild(acts);
            list.appendChild(row);
          });
        };
        refreshList();

        function uploadFile(f){
          const mb = f.size / (1024*1024);
          if (mb > UPLOAD_MAX_MB) { alert('Archivo demasiado grande (máx '+UPLOAD_MAX_MB+' MB)'); return; }
          const fd = new FormData(); fd.append('file', f); fd.append('key', '{{ flow_key }}');
          fetch('/internal/upload/', { method:'POST', body: fd })
            .then(r=>r.json())
            .then(j=>{
              if (j.error) throw new Error(j.error);
              const ext = (j.ext||'').toLowerCase();
              const isImage = ['.jpg','.jpeg','.png','.webp'].includes(ext);
              ensureArr();
              flow.nodes[id].assets.push({ type: isImage?'image':'file', url: j.url, name: j.name||f.name, size: f.size });
              refreshList();
            })
            .catch(e=> alert('Error al subir: '+ e.message));
        }
        function pickFiles(){ const inp=document.createElement('input'); inp.type='file'; inp.accept='.jpg,.jpeg,.png,.webp,.pdf'; inp.multiple=true; inp.onchange=()=>{ Array.from(inp.files||[]).forEach(uploadFile); }; inp.click(); }
        pickBtn.onclick = (e)=>{ e.preventDefault(); pickFiles(); };
        urlBtn.onclick = (e)=>{ e.preventDefault(); const url=prompt('Pega la URL pública del archivo o imagen:'); if(!url) return; ensureArr(); const isImg=isImageUrl(url); flow.nodes[id].assets.push({ type:isImg?'image':'file', url:url, name:(url.split('/').pop()||'archivo') }); refreshList(); };
        // Drag & Drop
        ;['dragenter','dragover'].forEach(ev=> drop.addEventListener(ev,(e)=>{ e.preventDefault(); drop.classList.add('hover'); }));
        ;['dragleave','drop'].forEach(ev=> drop.addEventListener(ev,(e)=>{ e.preventDefault(); drop.classList.remove('hover'); }));
        drop.addEventListener('drop',(e)=>{ const files = e.dataTransfer?.files ? Array.from(e.dataTransfer.files) : []; files.forEach(uploadFile); });
        drop.addEventListener('click', (e)=>{ e.preventDefault(); pickFiles(); });
        el.appendChild(assetsBox);
      }
      if ((node.type||'action') === 'trigger') {
        const sc2 = document.createElement('span'); sc2.className='start-connector'; sc2.title='Arrastra para conectar este trigger con otro nodo';
        sc2.dataset.startConnector = id;
        sc2.addEventListener('mousedown', (e) => startConnect(e, id, null, sc2));
        el.appendChild(sc2);
      }

      if ((node.type||'action') !== 'advisor') {
        const btns = document.createElement('div'); btns.className='btns';
        const items = (node.buttons||[]);
        items.forEach((b, idx) => btns.appendChild(renderButtonRow(id, b, idx)));
        if (items.length < FLOW_LIMIT) {
          const add = document.createElement('button'); add.className='addRow'; add.textContent='+ Añadir botón';
          add.onclick = () => { addButton(id); };
          btns.appendChild(add);
        }
        el.appendChild(btns);

        // Conector inferior derecho para enlazar siguiente nodo cuando no hay botones
        const nc = document.createElement('span'); nc.className='node-connector'; nc.title='Arrastra para conectar este nodo con otro (flujo lineal)';
        nc.dataset.nodeConnector = id;
        nc.addEventListener('mousedown', (e) => startConnect(e, id, null, nc));
        el.appendChild(nc);
      }

  // Drag & drop por la cabecera (manilla)
  drag.addEventListener('mousedown', (e) => startDrag(e, el, id));
  // Doble clic: centrar en este nodo
  el.addEventListener('dblclick', () => centerOnNode(id));

      // Selección del nodo para mostrar toolbar
      el.addEventListener('mousedown', () => setSelected(id));

      return el;
    }

    function renderButtonRow(nodeId, b, idx){
      const row = document.createElement('div'); row.className='row';
      const title = document.createElement('input'); title.placeholder='Título'; title.value = b.title || '';
      title.oninput = () => { flow.nodes[nodeId].buttons[idx].title = title.value; refresh(); };
      // Conector visual (drag para enlazar otro nodo)
      const connector = document.createElement('span'); connector.className='connector'; connector.title='Arrastra a otra caja para conectar';
      connector.dataset.connector = `${nodeId}:${idx}`;
      connector.addEventListener('mousedown', (e) => startConnect(e, nodeId, idx, connector));

  const del = document.createElement('button'); del.className='delbtn'; del.setAttribute('aria-label','Quitar'); del.title='Quitar'; del.textContent='×';
      del.onclick = () => { removeButton(nodeId, idx); };
      row.appendChild(title); row.appendChild(connector); row.appendChild(del);
      return row;
    }

    function openAddNodeMenu(){ overlay.style.display='flex'; }
    function closeAddNodeMenu(){ overlay.style.display='none'; }
    function duplicateNode(origId){
      if (!flow.nodes[origId]) return;
      const baseId = origId + '_copy';
      const newId = uid(baseId);
      // Clonar a mano para evitar referencias compartidas
      const orig = flow.nodes[origId];
      const copy = JSON.parse(JSON.stringify(orig));
      // Nueva posición desplazada
      const p = orig.pos || { x: 40, y: 40 };
      copy.pos = { x: (p.x||0) + 30, y: (p.y||0) + 30 };
      flow.nodes[newId] = copy;
      refresh();
      return newId;
    }
    function addNodeOfType(type){
      const id = uid(type==='advisor'?'advisor':(type==='trigger'?'trigger':'node'));
      const base = { type: type||'action', text: '', buttons: [], pos: null };
      if (type==='advisor') base.phone='';
      if (type==='trigger') { base.trigger_type='keywords'; base.patterns=''; base.enabled = true; }
      flow.nodes[id] = base;
      if (!flow.start_node) flow.start_node = id; // como referencia de menú principal
      closeAddNodeMenu();
      refresh();
    }
    function deleteNode(id){
      if (!flow.nodes[id]) return;
      if (!confirm('¿Eliminar nodo '+id+'?')) return;
      delete flow.nodes[id];
      if (flow.start_node === id) flow.start_node = Object.keys(flow.nodes)[0] || null;
      // Quitar referencias next a este nodo
      for (const k of Object.keys(flow.nodes)) {
        const btns = flow.nodes[k].buttons||[];
        btns.forEach(b => { if (b.next === id) delete b.next; });
        // Quitar next desde nodos start
        if ((flow.nodes[k].type||'action') === 'start' && flow.nodes[k].next === id) {
          delete flow.nodes[k].next;
        }
      }
      refresh();
    }
    function renameNode(oldId, newId){
      if (!newId || newId===oldId || flow.nodes[newId]) { drawEdges(); return; }
      flow.nodes[newId] = flow.nodes[oldId]; delete flow.nodes[oldId];
      if (flow.start_node===oldId) flow.start_node=newId;
      for (const k of Object.keys(flow.nodes)) {
        (flow.nodes[k].buttons||[]).forEach(b => { if (b.next===oldId) b.next=newId; });
      }
      refresh();
    }
    function addButton(nodeId){
      const arr = flow.nodes[nodeId].buttons || (flow.nodes[nodeId].buttons=[]);
      if (arr.length >= FLOW_LIMIT) { alert('Máximo '+FLOW_LIMIT+' botones.'); return; }
      const first = Object.keys(flow.nodes)[0] || null;
      arr.push({ title: 'Opción', next: first });
      refresh();
    }
    function removeButton(nodeId, idx){
      const arr = flow.nodes[nodeId].buttons||[];
      arr.splice(idx, 1); refresh();
    }

    function refresh(){
      renderAll();
    }

    startNodeSel.addEventListener('change', () => {
      flow.start_node = startNodeSel.value || null; drawEdges();
    });

    function drawEdges(){
      // Limpia
      linesSvg.innerHTML = '<defs><marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#8a8aa8" /></marker></defs>';
      // Expandir el área del SVG para cubrir coordenadas negativas (lienzo infinito)
      const innerW = parseFloat(stageInner.style.width || '1200');
      const innerH = parseFloat(stageInner.style.height || '800');
      linesSvg.style.left = (-WORLD_PAD) + 'px';
      linesSvg.style.top = (-WORLD_PAD) + 'px';
  linesSvg.style.right = 'auto';
  linesSvg.style.bottom = 'auto';
      linesSvg.style.width = (innerW + WORLD_PAD*2) + 'px';
      linesSvg.style.height = (innerH + WORLD_PAD*2) + 'px';
      const OFFX = WORLD_PAD, OFFY = WORLD_PAD;
      // Recalcular posiciones
      const host = stageInner.getBoundingClientRect();
      const nodeCards = Array.from(document.querySelectorAll('.node'));
      const pos = {};
      nodeCards.forEach(card => {
        const id = card.dataset.nodeId;
        const r = card.getBoundingClientRect();
        pos[id] = { x: (r.left - host.left)/ZOOM, y: (r.top - host.top)/ZOOM, w: r.width/ZOOM, h: r.height/ZOOM };
      });
      // Posiciones de conectores (por botón)
      const connPos = {};
      document.querySelectorAll('[data-connector]').forEach(el => {
        const r = el.getBoundingClientRect();
        connPos[el.dataset.connector] = { x: (r.left - host.left + r.width/2)/ZOOM, y: (r.top - host.top + r.height/2)/ZOOM };
      });
      // Posición de entrada por nodo (inlet)
      const inletPos = {};
      nodeCards.forEach(card => {
        const inlet = card.querySelector('.inlet');
        if (inlet) {
          const r = inlet.getBoundingClientRect();
          inletPos[card.dataset.nodeId] = { x: (r.left - host.left + r.width/2)/ZOOM, y: (r.top - host.top + r.height/2)/ZOOM };
        }
      });
      // Posición del conector de inicio por nodo
      const startConnPos = {};
      document.querySelectorAll('[data-start-connector]').forEach(el => {
        const r = el.getBoundingClientRect();
        startConnPos[el.dataset.startConnector] = { x: (r.left - host.left + r.width/2)/ZOOM, y: (r.top - host.top + r.height/2)/ZOOM };
      });
      // Posición del conector de nodo acción
      const nodeConnPos = {};
      document.querySelectorAll('[data-node-connector]').forEach(el => {
        const r = el.getBoundingClientRect();
        nodeConnPos[el.dataset.nodeConnector] = { x: (r.left - host.left + r.width/2)/ZOOM, y: (r.top - host.top + r.height/2)/ZOOM };
      });
      // Pintar líneas next
      Object.entries(flow.nodes).forEach(([id, node]) => {
        (node.buttons||[]).forEach((b, idx) => {
          if (!b.next || !pos[id] || !pos[b.next]) return;
          const p1 = connPos[`${id}:${idx}`];
          const p2 = inletPos[b.next] || { x: pos[b.next].x, y: pos[b.next].y + pos[b.next].h/2 };
          if (!p1 || !p2) return;
          const x1 = p1.x + OFFX, y1 = p1.y + OFFY;
          const x2 = p2.x + OFFX, y2 = p2.y + OFFY;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2;
          const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d);
          // Atributos directos para compatibilidad en todos los navegadores
          path.setAttribute('class','edge');
          path.setAttribute('fill','none');
          path.setAttribute('stroke','#8a8aa8');
          path.setAttribute('stroke-width','2');
          path.setAttribute('marker-end','url(#arrow)');
          path.dataset.edge = 'btn';
          path.dataset.src = id;
          path.dataset.idx = String(idx);
          linesSvg.appendChild(path);
        });
  // Edge desde nodo start (si existe next)
        if ((node.type||'action') === 'start' && node.next && startConnPos[id] && inletPos[node.next]) {
          const p1 = startConnPos[id];
          const p2 = inletPos[node.next];
          const x1 = p1.x + OFFX, y1 = p1.y + OFFY; const x2 = p2.x + OFFX, y2 = p2.y + OFFY;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2; const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d); path.setAttribute('class','edge'); path.setAttribute('fill','none'); path.setAttribute('stroke','#8a8aa8'); path.setAttribute('stroke-width','2'); path.setAttribute('marker-end','url(#arrow)');
          path.dataset.edge = 'start';
          path.dataset.src = id;
          linesSvg.appendChild(path);
        }
        // Edge desde nodo trigger (si existe next)
        if ((node.type||'action') === 'trigger' && node.next && startConnPos[id] && inletPos[node.next]) {
          const p1 = startConnPos[id];
          const p2 = inletPos[node.next];
          const x1 = p1.x + OFFX, y1 = p1.y + OFFY; const x2 = p2.x + OFFX, y2 = p2.y + OFFY;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2; const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d); path.setAttribute('class','edge'); path.setAttribute('fill','none'); path.setAttribute('stroke','#8a8aa8'); path.setAttribute('stroke-width','2'); path.setAttribute('marker-end','url(#arrow)');
          path.dataset.edge = 'trigger';
          path.dataset.src = id;
          linesSvg.appendChild(path);
        }
        // Edge desde nodo action (si existe next)
        if ((node.type||'action') === 'action' && node.next && nodeConnPos[id] && inletPos[node.next]) {
          const p1 = nodeConnPos[id];
          const p2 = inletPos[node.next];
          const x1 = p1.x + OFFX, y1 = p1.y + OFFY; const x2 = p2.x + OFFX, y2 = p2.y + OFFY;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2; const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d); path.setAttribute('class','edge'); path.setAttribute('fill','none'); path.setAttribute('stroke','#8a8aa8'); path.setAttribute('stroke-width','2'); path.setAttribute('marker-end','url(#arrow)');
          path.dataset.edge = 'node';
          path.dataset.src = id;
          linesSvg.appendChild(path);
        }
      });
    }

    // Conexión visual (drag desde el conector a otro nodo)
  let connecting = null; // { nodeId, idx|null, x0, y0, preview }
    function startConnect(e, nodeId, idx, connectorEl){
      if (e.button !== 0) return; // solo clic izquierdo
      e.preventDefault();
      const rect = connectorEl.getBoundingClientRect();
      const host = stageInner.getBoundingClientRect();
      const x0 = (rect.left - host.left + rect.width/2)/ZOOM;
      const y0 = (rect.top - host.top + rect.height/2)/ZOOM;
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('class','preview');
      linesSvg.appendChild(p);
  connecting = { nodeId, idx, x0, y0, preview: p };
      document.addEventListener('mousemove', onConnectMove);
      document.addEventListener('mouseup', endConnect);
    }
    function onConnectMove(e){
      if (!connecting) return;
      const host = stageInner.getBoundingClientRect();
      const x1 = (e.clientX - host.left)/ZOOM; const y1 = (e.clientY - host.top)/ZOOM;
      const X0 = connecting.x0 + WORLD_PAD, Y0 = connecting.y0 + WORLD_PAD;
      const X1 = x1 + WORLD_PAD, Y1 = y1 + WORLD_PAD;
      const mx = (X0 + X1)/2;
      const d = `M ${X0} ${Y0} C ${mx} ${Y0}, ${mx} ${Y1}, ${X1} ${Y1}`;
      connecting.preview.setAttribute('d', d);
    }
    function endConnect(e){
      document.removeEventListener('mousemove', onConnectMove);
      document.removeEventListener('mouseup', endConnect);
      if (!connecting) return;
      // Buscar nodo bajo el puntero
      const el = document.elementFromPoint(e.clientX, e.clientY);
      let card = el;
      while (card && !card.classList?.contains('node')) card = card.parentElement;
      if (card && card.dataset.nodeId) {
        const target = card.dataset.nodeId;
        // Evitar auto-conexión al mismo nodo
        if (target === connecting.nodeId) {
          showToast('No puedes conectar un nodo consigo mismo.', true);
        } else {
        if (connecting.idx === null) {
          // Conexión desde nodo de inicio
          flow.nodes[connecting.nodeId].next = target;
        } else {
          const btns = flow.nodes[connecting.nodeId].buttons || [];
          btns[connecting.idx] = { title: btns[connecting.idx]?.title || 'Opción', next: target };
          flow.nodes[connecting.nodeId].buttons = btns;
        }
        }
      }
      // limpiar preview
      if (connecting.preview && connecting.preview.parentNode) connecting.preview.parentNode.removeChild(connecting.preview);
      connecting = null;
      refresh();
    }

    function startDrag(e, el, id){
      if (e.button !== 0) return; // solo clic izquierdo
      e.preventDefault();
      const r = el.getBoundingClientRect();
      dragging = { id, el, offsetX: (e.clientX - r.left)/ZOOM, offsetY: (e.clientY - r.top)/ZOOM };
      document.addEventListener('mousemove', onDragMove);
      document.addEventListener('mouseup', endDrag);
    }
    function onDragMove(e){
      if (!dragging) return;
      const host = stageInner.getBoundingClientRect();
      let x = (e.clientX - host.left)/ZOOM - dragging.offsetX;
      let y = (e.clientY - host.top)/ZOOM - dragging.offsetY;
      // Permitir coordenadas negativas dentro del padding virtual
      const MIN_COORD = -WORLD_PAD + 200; // margen de seguridad
      if (x < MIN_COORD) x = MIN_COORD;
      if (y < MIN_COORD) y = MIN_COORD;
      dragging.el.style.left = x + 'px';
      dragging.el.style.top = y + 'px';
      const n = flow.nodes[dragging.id];
      if (n) n.pos = { x, y };
      drawEdges();
      if (selectedNodeId === dragging.id) positionToolbar();
    }
    function endDrag(){
      document.removeEventListener('mousemove', onDragMove);
      document.removeEventListener('mouseup', endDrag);
      dragging = null;
    }

    function saveFlow(){
      // Normalizar botones a solo next o id
      for (const k of Object.keys(flow.nodes)) {
        // Mantener posición actual
        const card = nodesEl.querySelector(`.node[data-node-id="${k}"]`);
        if (card) {
          const left = parseInt(card.style.left || '0', 10);
          const top = parseInt(card.style.top || '0', 10);
          flow.nodes[k].pos = { x: left, y: top };
        }
        flow.nodes[k].buttons = (flow.nodes[k].buttons||[]).slice(0, FLOW_LIMIT).map(b => {
          const out = { title: b.title||'Opción' };
          if (b.next) out.next = b.next; else if (b.id) out.id = b.id.trim();
          return out;
        });
        // Asegurar type/phone/keywords/assets persisten
        flow.nodes[k].type = flow.nodes[k].type || 'action';
        if (flow.nodes[k].type==='advisor') {
          flow.nodes[k].phone = (flow.nodes[k].phone||'').trim();
          // Normalizar links
          const links = flow.nodes[k].links;
          const norm = {};
          ['web','fb','ig','tiktok'].forEach(key => {
            const it = links && links[key] ? links[key] : null;
            if (it && (it.url||'').trim()) {
              norm[key] = { enabled: !!it.enabled, url: (it.url||'').trim() };
            }
          });
          if (Object.keys(norm).length > 0) {
            flow.nodes[k].links = norm;
            flow.nodes[k].include_links = Object.values(norm).some(v => v.enabled);
          } else {
            delete flow.nodes[k].links;
            flow.nodes[k].include_links = !!flow.nodes[k].include_links; // mantener compatibilidad
          }
          // Timeout por inactividad
          const tm = parseInt(flow.nodes[k].timeout_min||flow.nodes[k].human_timeout_min||15, 10);
          flow.nodes[k].timeout_min = isNaN(tm)?15:Math.max(1, Math.min(720, tm));
        }
        // (start eliminado del editor)
        if (flow.nodes[k].type==='trigger') {
          const t = (flow.nodes[k].trigger_type||'keywords');
          flow.nodes[k].trigger_type = t;
          flow.nodes[k].enabled = (typeof flow.nodes[k].enabled === 'boolean') ? !!flow.nodes[k].enabled : true;
          if (t === 'ai') {
            const ins = (flow.nodes[k].instruction||'').toString();
            if (ins.trim()) flow.nodes[k].instruction = ins.trim(); else delete flow.nodes[k].instruction;
            delete flow.nodes[k].patterns;
          } else {
            const pat = (flow.nodes[k].patterns||'').toString();
            flow.nodes[k].patterns = pat;
            delete flow.nodes[k].instruction;
          }
          if (flow.nodes[k].next) flow.nodes[k].next = String(flow.nodes[k].next);
          if ('text' in flow.nodes[k]) delete flow.nodes[k].text;
        }
        // assets eliminados del editor
      }
  const payload = JSON.stringify(flow, null, 2);
      // Guardar por fetch JSON para no salir del builder
      const fd = new FormData();
      fd.append('content', payload);
      fetch('/flow?key={{ flow_key }}&format=json', { method: 'POST', body: fd })
        .then(async (r) => {
          if (!r.ok) throw new Error((await r.json()).error || 'Error al guardar');
          return r.json();
        })
        .then(() => showToast('✅ Flujo guardado correctamente.'))
        .catch(err => showToast('❌ Error al guardar: ' + err.message, true));
    }

    function reloadFromServer(){
      window.location.reload();
    }

    function openPreview(){
      const ov = document.getElementById('previewOverlay');
      const fr = document.getElementById('previewFrame');
      fr.src = '/chat';
      ov.style.display = 'flex';
      layoutPhone();
    }
    function closePreview(){
      const ov = document.getElementById('previewOverlay');
      const fr = document.getElementById('previewFrame');
      fr.src = 'about:blank';
      ov.style.display = 'none';
    }
    document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closePreview(); });
    // Cerrar haciendo click fuera del panel
    (function(){
      const ov = document.getElementById('previewOverlay');
      const panel = ov.querySelector('.panel');
      ov.addEventListener('click', (e)=>{ if (e.target === ov) closePreview(); });
    })();

    // IA Config modal
    function openAIConfig(){
      importAIFromFlow();
      document.getElementById('aiOverlay').style.display='flex';
    }
    function closeAIConfig(){ document.getElementById('aiOverlay').style.display='none'; }
    document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeAIConfig(); });
    (function(){ const ov = document.getElementById('aiOverlay'); ov.addEventListener('click', (e)=>{ if (e.target===ov) closeAIConfig(); }); })();
    function importAIFromFlow(){
      try{
        const cfg = (flow.ai_config||{});
        const p = cfg.assistant_profile || {};
        const set=(id,val)=>{ const el=document.getElementById(id); if(el) el.value = val || ''; };
        set('ai_name', p.assistant_name||'');
        set('ai_lang', p.language||'');
        set('ai_site', p.website_url||'');
        set('ai_phone', p.phone_number||'');
        set('ai_email', p.email||'');
        set('ai_required', Array.isArray(p.required_order_info)? p.required_order_info.join('\n') : '');
        set('ai_oos', Array.isArray(cfg.not_supported)? cfg.not_supported.join('\n') : '');
        set('ai_policies', Array.isArray(cfg.policies)? cfg.policies.join('\n') : '');
        // Políticas de comunicación (checkboxes derivados de policies)
        try{
          const pol = Array.isArray(cfg.policies)? cfg.policies : [];
          const hasNoInvent = pol.some(s => /no\s*inventar/i.test(s||''));
          const hasNoSwear = pol.some(s => /(groser|ofensiv|insult)/i.test(s||''));
          const c1 = document.getElementById('pol_no_invent'); if (c1) c1.checked = hasNoInvent;
          const c2 = document.getElementById('pol_no_swear'); if (c2) c2.checked = hasNoSwear;
        }catch(_e){}

        // Business profile
        const b = cfg.business_profile || {};
        set('biz_name', b.business_name||'');
        set('biz_legal_name', b.legal_name||'');
        set('biz_ruc', b.ruc||'');
        set('biz_tz', (b.hours&&b.hours.timezone)||'');
        const addr = b.address||{};
        set('biz_addr', addr.address_line||'');
        set('biz_city', addr.city||'');
        set('biz_region', addr.region||'');
        set('biz_country', addr.country||'');
        set('biz_maps', addr.maps_url||b.socials?.google_maps||'');
        set('biz_ubigeo', addr.ubigeo||'');
        const hrs = b.hours||{};
        set('biz_hours_week', hrs.weekdays||'');
        set('biz_hours_sat', hrs.saturday||'');
        set('biz_hours_sun', hrs.sunday||'');
        const s = b.socials||{};
        set('soc_ig', s.instagram||'');
        set('soc_fb', s.facebook||'');
        set('soc_tt', s.tiktok||'');
        set('soc_yt', s.youtube||'');
        set('soc_x', s.x||'');
        set('soc_lt', s.linktree||'');
        set('soc_wa', s.whatsapp_link||'');
        set('soc_web', s.website||'');
        const pay = b.payments||{};
        const yp = pay.yape||{}; set('pay_yape_phone', yp.phone||''); set('pay_yape_holder', yp.holder||''); set('pay_yape_alias', yp.alias||''); set('pay_yape_qr', yp.qr_url||'');
        const pl = pay.plin||{}; set('pay_plin_phone', pl.phone||''); set('pay_plin_holder', pl.holder||''); set('pay_plin_qr', pl.qr_url||'');
        const cr = pay.card||{}; set('pay_card_brands', Array.isArray(cr.brands)? cr.brands.join(', ') : (cr.brands||'')); set('pay_card_provider', cr.provider||''); set('pay_card_link', cr.link_url||''); set('pay_card_notes', cr.surcharge||cr.notes||'');
        const tf = pay.transfer||{}; set('pay_tf_instr', tf.instructions||'');
        // Banks -> textarea
        const banksTxt = Array.isArray(tf.banks)? tf.banks.map(bk => [bk.bank||'', bk.account_number||'', bk.cci||'', bk.holder||'', bk.doc||''].join('; ')).join('\n') : '';
        set('pay_tf_banks', banksTxt);
        set('pay_cod', (pay.cod && (pay.cod.notes||'Sí')) || '');
        const ship = b.shipping||{};
        const dRates = Array.isArray(ship.district_rates)? ship.district_rates.map(dr => [dr.district||'', dr.price||'', dr.eta||''].join('; ')).join('\n') : '';
        set('ship_districts', dRates||ship.coverage_text||'');
        set('ship_eta', ship.delivery_time||'');
        set('ship_free', ship.free_shipping_threshold||'');
        set('ship_pickup', ship.pickup_address||'');
        set('ship_partners', Array.isArray(ship.partners)? ship.partners.join(', ') : (ship.partners||''));
        // Modalidad de venta
        const sales = b.sales||{};
        const retail = sales.retail||{}; const wholesale = sales.wholesale||{};
        set('sales_retail', retail.enabled ? 'Sí' : (retail.enabled===false?'No':''));
        set('sales_wholesale', wholesale.enabled ? 'Sí' : (wholesale.enabled===false?'No':''));
        set('sales_wh_min', wholesale.min_units||'');
        set('sales_wh_price_list', wholesale.price_list_url||'');
        set('sales_wh_requires_ruc', (typeof wholesale.requires_ruc==='boolean') ? (wholesale.requires_ruc?'Sí':'No') : '');
        set('sales_wh_prep', wholesale.prep_time||'');
        const whDisc = Array.isArray(wholesale.discounts)? wholesale.discounts.map(d => [d.from_units||'', d.percent||''].join('; ')).join('\n') : '';
        set('sales_wh_discounts', whDisc);
      }catch(_){ /* noop */ }
    }
    function applyAIToFlow(){
      const profile = {
        assistant_name: document.getElementById('ai_name')?.value||'',
        required_order_info: (document.getElementById('ai_required')?.value||'').split(/\r?\n/).map(s=>s.trim()).filter(Boolean),
        language: document.getElementById('ai_lang')?.value||'',
        website_url: document.getElementById('ai_site')?.value||'',
        phone_number: document.getElementById('ai_phone')?.value||'',
        email: document.getElementById('ai_email')?.value||''
      };
      flow.ai_config = flow.ai_config || {};
      flow.ai_config.assistant_profile = profile;
  const notSupported = (document.getElementById('ai_oos')?.value||'').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  let policies = (document.getElementById('ai_policies')?.value||'').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  // Políticas de comunicación
  const addOnce = (arr, s) => { if (!arr.some(x=>x.toLowerCase()===s.toLowerCase())) arr.push(s); };
  if (document.getElementById('pol_no_invent')?.checked) addOnce(policies, 'No inventar información; si falta, pedirla o derivar a humano.');
  if (document.getElementById('pol_no_swear')?.checked) addOnce(policies, 'No usar ni responder con groserías o lenguaje ofensivo.');
      if (notSupported.length) flow.ai_config.not_supported = notSupported; else delete flow.ai_config.not_supported;
      if (policies.length) flow.ai_config.policies = policies; else delete flow.ai_config.policies;
      // Business profile build
      const val = id => (document.getElementById(id)?.value||'').trim();
      const brands = val('pay_card_brands').split(',').map(s=>s.trim()).filter(Boolean);
      const partners = val('ship_partners').split(',').map(s=>s.trim()).filter(Boolean);
      const banks = val('pay_tf_banks').split(/\r?\n/).map(line => {
        const parts = line.split(';').map(s=>s.trim());
        if (!parts.filter(Boolean).length) return null;
        return { bank: parts[0]||'', account_number: parts[1]||'', cci: parts[2]||'', holder: parts[3]||'', doc: parts[4]||'' };
      }).filter(Boolean);
      const dRates = val('ship_districts').split(/\r?\n/).map(line => {
        const parts = line.split(';').map(s=>s.trim());
        if (!parts.filter(Boolean).length) return null;
        return { district: parts[0]||'', price: parts[1]||'', eta: parts[2]||'' };
      }).filter(Boolean);
      const business_profile = {
        business_name: val('biz_name'),
        legal_name: val('biz_legal_name'),
        ruc: val('biz_ruc'),
        address: {
          address_line: val('biz_addr'),
          city: val('biz_city'),
          region: val('biz_region'),
          country: val('biz_country'),
          maps_url: val('biz_maps'),
          ubigeo: val('biz_ubigeo')
        },
        hours: {
          weekdays: val('biz_hours_week'),
          saturday: val('biz_hours_sat'),
          sunday: val('biz_hours_sun'),
          timezone: val('biz_tz')
        },
        socials: {
          instagram: val('soc_ig'),
          facebook: val('soc_fb'),
          tiktok: val('soc_tt'),
          youtube: val('soc_yt'),
          x: val('soc_x'),
          linktree: val('soc_lt'),
          whatsapp_link: val('soc_wa'),
          website: val('soc_web')
        },
        payments: {
          yape: {
            phone: val('pay_yape_phone'),
            holder: val('pay_yape_holder'),
            alias: val('pay_yape_alias'),
            qr_url: val('pay_yape_qr')
          },
          plin: {
            phone: val('pay_plin_phone'),
            holder: val('pay_plin_holder'),
            qr_url: val('pay_plin_qr')
          },
          card: {
            brands: brands,
            provider: val('pay_card_provider'),
            link_url: val('pay_card_link'),
            surcharge: val('pay_card_notes')
          },
          transfer: {
            banks: banks,
            instructions: val('pay_tf_instr')
          },
          cod: {
            notes: val('pay_cod')
          }
        },
        shipping: {
          district_rates: dRates,
          delivery_time: val('ship_eta'),
          free_shipping_threshold: val('ship_free'),
          pickup_address: val('ship_pickup'),
          partners: partners
        },
        sales: {
          retail: { enabled: /^si/i.test(val('sales_retail')) },
          wholesale: {
            enabled: /^si/i.test(val('sales_wholesale')),
            min_units: val('sales_wh_min'),
            discounts: (val('sales_wh_discounts')? val('sales_wh_discounts').split(/\r?\n/).map(line=>{ const p=line.split(';').map(s=>s.trim()); if(!p.filter(Boolean).length) return null; return { from_units: p[0]||'', percent: p[1]||'' }; }).filter(Boolean):[]),
            price_list_url: val('sales_wh_price_list'),
            requires_ruc: /^si/i.test(val('sales_wh_requires_ruc')),
            prep_time: val('sales_wh_prep')
          }
        },
        policies: {
          returns: val('pol_returns'),
          warranty: val('pol_warranty'),
          terms_url: val('pol_terms'),
          privacy_url: val('pol_privacy'),
          invoices: {
            boleta: /^si/i.test(val('pol_boleta')),
            factura: /^si/i.test(val('pol_factura'))
          }
        }
      };
      // Solo asignar si hay algo relevante
      const hasAny = JSON.stringify(business_profile).replace(/\W/g,'').length > 0;
      if (hasAny) flow.ai_config.business_profile = business_profile; else delete flow.ai_config.business_profile;
      // Garantizar base del flujo
      if (!flow.enabled && flow.enabled!==false) flow.enabled = true;
      if (!flow.start_node) flow.start_node = Object.keys(flow.nodes||{})[0] || null;
      if (!flow.nodes) flow.nodes = {};
    }

    // Layout: simular teléfono con proporción 19.5:9 y escalar si no cabe en 95vh
    function layoutPhone(){
      const ov = document.getElementById('previewOverlay');
      const bar = ov.querySelector('.bar');
      const device = ov.querySelector('.device');
      if (!ov || !bar || !device) return;
      const R = 19.5/9; // alto/ancho típico moderno
      const W = 420; // ancho fijo S
      device.style.width = W + 'px';
      device.style.height = (W * R) + 'px';
      // Escalar si la altura total excede 95vh
      const barH = bar.getBoundingClientRect().height;
      const maxH = window.innerHeight * 0.95 - barH - 16; // margen interno
      const devRect = device.getBoundingClientRect();
      const needH = devRect.height; // ya con alto según R
      const scale = Math.min(1, maxH / needH);
      device.style.transform = 'scale(' + scale + ')';
      device.style.transformOrigin = 'center top';
    }
    window.addEventListener('resize', layoutPhone);

    // Toolbar flotante de nodos
    let selectedNodeId = null;
    const toolbar = document.getElementById('nodeToolbar');
    toolbar.addEventListener('click', (ev)=>{
      const act = ev.target?.dataset?.action;
      if (!act || !selectedNodeId) return;
      if (act==='dup') {
        const newId = duplicateNode(selectedNodeId);
        if (newId) {
          // Esperar al re-render y seleccionar la copia
          setTimeout(()=>{ setSelected(newId); }, 0);
        } else {
          positionToolbar();
        }
      }
      if (act==='del') { const id = selectedNodeId; hideToolbar(); deleteNode(id); }
      if (act==='start') { flow.start_node = selectedNodeId; refresh(); positionToolbar(); }
      if (act==='more') { alert('Pronto agregaremos más acciones 😉'); }
    });

    function setSelected(id){
      selectedNodeId = id;
      document.querySelectorAll('.node').forEach(n => n.classList.toggle('selected', n.dataset.nodeId===id));
      positionToolbar();
    }
    function hideToolbar(){
      selectedNodeId = null;
      toolbar.style.display = 'none';
      document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
    }
    function positionToolbar(){
      if (!selectedNodeId) { toolbar.style.display='none'; return; }
      const card = document.querySelector(`.node[data-node-id="${selectedNodeId}"]`);
      if (!card) { toolbar.style.display='none'; return; }
      const canvasRect = canvasEl.getBoundingClientRect();
      const r = card.getBoundingClientRect();
      // Colocar centrado arriba del card, relativo al canvas scroll
      const left = (r.left - canvasRect.left) + canvasEl.scrollLeft + (r.width/2);
      const top = (r.top - canvasRect.top) + canvasEl.scrollTop - 12; // un poco encima
      toolbar.style.left = left + 'px';
      toolbar.style.top = top + 'px';
      toolbar.style.transform = 'translate(-50%, -110%)';
      toolbar.style.display = 'block';
    }
    // Deselect al hacer click en fondo del canvas
    canvasEl.addEventListener('mousedown', (e)=>{
      // No cerrar si se clickea dentro de la toolbar
      if (toolbar.contains(e.target) || e.button !== 0) return; // solo clic izquierdo para deseleccionar
      let el = e.target;
      while (el && el !== canvasEl && !el.classList?.contains('node')) el = el.parentElement;
      if (el === canvasEl) hideToolbar();
    });

    // Tema (claro/oscuro) con persistencia
    (function(){
      const root = document.documentElement;
      const btn = document.getElementById('themeBtn');
      const saved = localStorage.getItem('optichat-theme') || 'light';
      if (saved === 'light') root.setAttribute('data-theme','light');
      btn.textContent = 'Tema: ' + (root.getAttribute('data-theme')==='light' ? 'Claro' : 'Oscuro');
      btn.addEventListener('click', ()=>{
        const cur = root.getAttribute('data-theme')==='light' ? 'light' : 'dark';
        const next = cur==='light' ? 'dark' : 'light';
        if (next==='light') root.setAttribute('data-theme','light'); else root.removeAttribute('data-theme');
        localStorage.setItem('optichat-theme', next);
        btn.textContent = 'Tema: ' + (next==='light' ? 'Claro' : 'Oscuro');
      });
    })();

    // Toggle de sidebar (mostrar/ocultar) con persistencia
    (function(){
      const wrap = document.querySelector('.wrap');
  const sidebar = document.querySelector('.sidebar');
  const btnCollapse = document.getElementById('collapseHandle');
  const btnExpand = document.getElementById('expandHandle');
  const btnHdr = document.getElementById('toggleSidebarHdr');
      function setSidebarCollapsed(on){
        sidebar.classList.toggle('collapsed', !!on);
        wrap.classList.toggle('sidebar-collapsed', !!on);
        localStorage.setItem('optichat-sidebar-collapsed', on ? '1' : '0');
        // Recalcular líneas/conectores tras el cambio
        setTimeout(()=>{ drawEdges(); positionToolbar(); }, 0);
        updateHdrLabel();
        // Si se expande, quitar modo failsafe del botón
        if (!on && btnExpand) btnExpand.classList.remove('failsafe');
      }
      function updateHdrLabel(){
        if (!btnHdr) return;
        const collapsed = sidebar.classList.contains('collapsed');
        btnHdr.textContent = collapsed ? '☰ Nodos' : '◁ Ocultar';
      }
      if (btnCollapse) btnCollapse.addEventListener('click', ()=>{ setSidebarCollapsed(true); });
      if (btnExpand) btnExpand.addEventListener('click', ()=>{ setSidebarCollapsed(false); });
      if (btnHdr) btnHdr.addEventListener('click', ()=>{
        const collapsed = sidebar.classList.contains('collapsed');
        setSidebarCollapsed(!collapsed);
      });
  const savedSide = localStorage.getItem('optichat-sidebar-collapsed');
  // Asegurar que siempre se apliquen las clases iniciales (evita estados "fantasma")
  if (savedSide === '1' || savedSide === 'true') {
        setSidebarCollapsed(true);
      } else {
        setSidebarCollapsed(false);
        // Fallback: si por cualquier razón el sidebar está visualmente invisible (ancho ~0)
        // pero no hay clases aplicadas, mostramos la manija en modo failsafe.
        try {
          const sbRect = sidebar.getBoundingClientRect();
          const hasCollapsedCls = sidebar.classList.contains('collapsed') || wrap.classList.contains('sidebar-collapsed');
          if (!hasCollapsedCls && sbRect.width < 20 && btnExpand) {
            btnExpand.classList.add('failsafe');
          }
        } catch(_) {}
      }

      // Atajo de teclado: Alt+N para alternar el panel Nodos
      document.addEventListener('keydown', (ev)=>{
        if (ev.altKey && (ev.key==='n' || ev.key==='N')){
          ev.preventDefault();
          const collapsed = sidebar.classList.contains('collapsed');
          setSidebarCollapsed(!collapsed);
        }
      });
    })();

    // Centrar vista en un nodo
    function centerOnNode(id){
      const card = document.querySelector(`.node[data-node-id="${id}"]`);
      if (!card) return;
      const cRect = card.getBoundingClientRect();
      const vRect = canvasEl.getBoundingClientRect();
      const dx = (cRect.left - vRect.left) + canvasEl.scrollLeft - (vRect.width/2 - cRect.width/2);
      const dy = (cRect.top - vRect.top) + canvasEl.scrollTop - (vRect.height/2 - cRect.height/2);
      canvasEl.scrollLeft = dx; canvasEl.scrollTop = dy;
      positionToolbar();
    }

    // Ajustar a pantalla: encuadrar todo el contenido visible de stageInner
    function fitToView(){
      // Estimar contenido actual
      let maxX = 1200, maxY = 800;
      const host = stageInner.getBoundingClientRect();
      const cards = Array.from(document.querySelectorAll('.node'));
      cards.forEach(card => {
        const r = card.getBoundingClientRect();
        const right = (r.right - host.left)/ZOOM;
        const bottom = (r.bottom - host.top)/ZOOM;
        maxX = Math.max(maxX, right + 60);
        maxY = Math.max(maxY, bottom + 60);
      });
      const cw = canvasEl.clientWidth;
      const ch = canvasEl.clientHeight;
      const scale = Math.min(cw / Math.max(300, maxX), ch / Math.max(240, maxY));
      const nz = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, scale));
      // Aplicar zoom y recentrar
      const oldPad = WORLD_PAD;
      ZOOM = nz;
      updateStageSize();
      drawEdges();
      // Centrar el área ocupada
      const padX = parseFloat(getComputedStyle(stageInner).marginLeft)||0;
      const padY = parseFloat(getComputedStyle(stageInner).marginTop)||0;
      const worldW = maxX * ZOOM;
      const worldH = maxY * ZOOM;
      canvasEl.scrollLeft = padX + (worldW - cw)/2;
      canvasEl.scrollTop = padY + (worldH - ch)/2;
      zoomHud.textContent = Math.round(ZOOM*100) + '% (rueda: zoom, rueda presionada o Space: mover)';
      positionToolbar();
    }

    // Botón "Ajustar"
    (function(){
      const fitBtn = document.getElementById('fitBtn');
      if (fitBtn) fitBtn.addEventListener('click', (e)=>{ e.preventDefault(); fitToView(); });
    })();

    function showToast(msg, isError){
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.style.background = isError ? '#dc3545' : '#1e7e34';
      t.style.display = 'block';
      clearTimeout(window.__toastTimer);
      window.__toastTimer = setTimeout(() => { t.style.display = 'none'; }, 2000);
    }

    // Click en flechas para eliminar conexión
    // Menú contextual de arista (flecha)
    const edgeMenu = (function(){
      const d = document.createElement('div'); d.id='edgeMenu'; d.className='edge-menu';
  d.innerHTML = '<div class="item" data-act="goto">→ Ve el bloque vinculado</div>\
         <div class="item danger" data-act="del"><svg viewBox="0 0 24 24" aria-hidden="true" style="width:16px;height:16px;stroke:currentColor;fill:none;stroke-width:1.8;stroke-linecap:round;stroke-linejoin:round; margin-right:4px;"><path d="M3 6h18"></path><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path><path d="M10 11v6M14 11v6"></path></svg>Eliminar el camino</div>';
      document.body.appendChild(d);
      return d;
    })();

    function getEdgeTargetId(type, src, idx){
      if (!flow.nodes[src]) return null;
      if (type==='btn') {
        const i = parseInt(idx||'-1', 10);
        return (!isNaN(i) && flow.nodes[src].buttons && flow.nodes[src].buttons[i]) ? (flow.nodes[src].buttons[i].next||null) : null;
      }
      return flow.nodes[src].next || null;
    }
    function showEdgeMenu(el, clientX, clientY){
      const type = el.dataset.edge; const src = el.dataset.src; const idx = el.dataset.idx;
      if (!type || !src) return;
      const targetId = getEdgeTargetId(type, src, idx);
      edgeMenu.dataset.type = type; edgeMenu.dataset.src = src; edgeMenu.dataset.idx = idx||''; edgeMenu.dataset.target = targetId||'';
      // Posicionar relativo al viewport (evitamos scrollbars)
      let left = clientX + 8;
      let top = clientY + 8;
      // Evitar salir por los bordes de la ventana
      const vw = window.innerWidth, vh = window.innerHeight;
      const mw = 240, mh = 90; // tamaño aproximado del menú
      if (left + mw > vw) left = vw - mw - 10;
      if (top + mh > vh) top = vh - mh - 10;
      edgeMenu.style.left = left + 'px';
      edgeMenu.style.top = top + 'px';
      edgeMenu.style.display = 'block';
    }
    function hideEdgeMenu(){ edgeMenu.style.display='none'; }
    edgeMenu.addEventListener('mousedown', (e)=> e.stopPropagation());
    document.addEventListener('mousedown', hideEdgeMenu);
    document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideEdgeMenu(); });
    edgeMenu.addEventListener('click', (e)=>{
      const act = e.target?.closest('.item')?.dataset?.act;
      if (!act) return;
      const type = edgeMenu.dataset.type; const src = edgeMenu.dataset.src; const idx = edgeMenu.dataset.idx; const target = edgeMenu.dataset.target;
      if (act==='del'){
        if (!src || !flow.nodes[src]) { hideEdgeMenu(); return; }
        if (type==='btn'){
          const i = parseInt(idx||'-1',10);
          if (!isNaN(i) && flow.nodes[src].buttons && flow.nodes[src].buttons[i]) delete flow.nodes[src].buttons[i].next;
        } else {
          delete flow.nodes[src].next;
        }
        hideEdgeMenu(); refresh();
      }
      if (act==='goto'){
        if (target && flow.nodes[target]){
          // Centrar el nodo destino y seleccionarlo
          const card = document.querySelector(`.node[data-node-id="${target}"]`);
          if (card){
            const cRect = card.getBoundingClientRect();
            const vRect = canvasEl.getBoundingClientRect();
            const dx = (cRect.left - vRect.left) + canvasEl.scrollLeft - (vRect.width/2 - cRect.width/2);
            const dy = (cRect.top - vRect.top) + canvasEl.scrollTop - (vRect.height/2 - cRect.height/2);
            canvasEl.scrollLeft = dx; canvasEl.scrollTop = dy;
            setSelected(target);
            hideEdgeMenu();
          }
        } else {
          showToast('Esta flecha no tiene destino asignado.', true);
        }
      }
    });

    linesSvg.addEventListener('click', (e) => {
      const el = e.target;
      if (!(el instanceof SVGPathElement)) return;
      const type = el.dataset?.edge; if (!type) return;
      e.stopPropagation();
      e.preventDefault();
      showEdgeMenu(el, e.clientX, e.clientY);
    });

    // También soportar clic derecho sobre la línea
    linesSvg.addEventListener('contextmenu', (e) => {
      const el = e.target;
      if (!(el instanceof SVGPathElement)) return;
      const type = el.dataset?.edge; if (!type) return;
      e.preventDefault();
      e.stopPropagation();
      showEdgeMenu(el, e.clientX, e.clientY);
    });

    function updateStatusChip(){
      const chip = document.getElementById('statusChip');
      if (!chip) return;
      const on = !!(flow && flow.enabled);
      chip.textContent = on ? 'Activo' : 'Inactivo';
      chip.classList.toggle('on', on);
      chip.classList.toggle('off', !on);
    }

    // Zoom helpers
    function setZoom(nextZoom, pivotClientX, pivotClientY){
      const old = ZOOM; const nz = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, nextZoom));
      if (Math.abs(nz - old) < 0.001) return;
      // Mantener foco bajo el cursor
      const rect = canvasEl.getBoundingClientRect();
      const clientX = (pivotClientX ?? (rect.left + rect.width/2));
      const clientY = (pivotClientY ?? (rect.top + rect.height/2));
      const pxScaled = (clientX - rect.left) + canvasEl.scrollLeft;
      const pyScaled = (clientY - rect.top) + canvasEl.scrollTop;
      // Considerar padding virtual (márgenes) del mundo infinito
      const cs = getComputedStyle(stageInner);
      const padX = parseFloat(cs.marginLeft) || 0;
      const padY = parseFloat(cs.marginTop) || 0;
      const worldX = (pxScaled - padX) / old;
      const worldY = (pyScaled - padY) / old;

      ZOOM = nz;
      updateStageSize();
      drawEdges();

      const newPxScaled = worldX * ZOOM + padX;
      const newPyScaled = worldY * ZOOM + padY;
      canvasEl.scrollLeft = newPxScaled - (clientX - rect.left);
      canvasEl.scrollTop = newPyScaled - (clientY - rect.top);
      zoomHud.textContent = Math.round(ZOOM*100) + '% (rueda: zoom, rueda presionada: mover)';
      positionToolbar();
    }
    function updateStageSize(){
      // calcular mundo según DOM real (más preciso con textareas/botones)
      let maxX = 1200, maxY = 800;
      const host = stageInner.getBoundingClientRect();
      const cards = Array.from(document.querySelectorAll('.node'));
      cards.forEach(card => {
        const r = card.getBoundingClientRect();
        const right = (r.right - host.left)/ZOOM;
        const bottom = (r.bottom - host.top)/ZOOM;
        maxX = Math.max(maxX, right + 200);
        maxY = Math.max(maxY, bottom + 200);
      });
  // Dimensiones con “mundo” ampliado para pan en 4 direcciones
  const PAD = WORLD_PAD; // espacio extra alrededor para simular lienzo infinito
  const scaledW = maxX * ZOOM;
  const scaledH = maxY * ZOOM;
  const cw = canvasEl.clientWidth;
  const ch = canvasEl.clientHeight;
  const areaW = Math.max(scaledW + PAD*2, cw + PAD*2);
  const areaH = Math.max(scaledH + PAD*2, ch + PAD*2);
  stageEl.style.width = areaW + 'px';
  stageEl.style.height = areaH + 'px';
  stageInner.style.width = maxX + 'px';
  stageInner.style.height = maxY + 'px';
  stageInner.style.transform = `scale(${ZOOM})`;
  stageInner.style.marginLeft = PAD + 'px';
  stageInner.style.marginTop = PAD + 'px';
      if (!window.__worldInit) {
        canvasEl.scrollLeft = PAD;
        canvasEl.scrollTop = PAD;
        window.__worldInit = true;
      }
    }

    // Zoom con la rueda del mouse (sin necesidad de Ctrl)
    canvasEl.addEventListener('wheel', (e) => {
      e.preventDefault();
      const factor = e.deltaY > 0 ? 0.9 : 1.1; // abajo: alejar, arriba: acercar
      setZoom(ZOOM * factor, e.clientX, e.clientY);
    }, { passive:false });

    // Pan con botón medio (rueda presionada) + arrastrar
    let __panning = false; let __panX = 0, __panY = 0;
    function startPan(e){
      if (e.button !== 1 && !(e.button===0 && window.__spacePressed)) return; // botón medio o botón izq + Space
      e.preventDefault();
      __panning = true; __panX = e.clientX; __panY = e.clientY;
      canvasEl.style.cursor = 'grabbing';
      document.addEventListener('mousemove', onPanMove);
      document.addEventListener('mouseup', endPan);
    }
    function onPanMove(e){
      if (!__panning) return;
      const dx = e.clientX - __panX; const dy = e.clientY - __panY;
      canvasEl.scrollLeft -= dx; canvasEl.scrollTop -= dy;
      __panX = e.clientX; __panY = e.clientY;
      drawEdges(); positionToolbar();
    }
    function endPan(){
      if (!__panning) return;
      __panning = false;
      canvasEl.style.cursor = '';
      document.removeEventListener('mousemove', onPanMove);
      document.removeEventListener('mouseup', endPan);
    }
    canvasEl.addEventListener('mousedown', startPan, { passive:false });
    // Space para pan con botón izquierdo
    window.__spacePressed = false;
    document.addEventListener('keydown', (e)=>{
      if (e.code === 'Space' && !e.repeat){ window.__spacePressed = true; if (!__panning) canvasEl.style.cursor = 'grab'; e.preventDefault(); }
      // Atajo: F para centrar seleccionado
      if ((e.key==='f' || e.key==='F') && selectedNodeId){ e.preventDefault(); centerOnNode(selectedNodeId); }
    });
    document.addEventListener('keyup', (e)=>{
      if (e.code === 'Space'){ window.__spacePressed = false; if (!__panning) canvasEl.style.cursor = ''; }
    });

    // Primer render
    renderAll();
  window.addEventListener('resize', ()=>{ drawEdges(); positionToolbar(); });
    // Redibujar al desplazar el lienzo
    canvasEl.addEventListener('scroll', ()=>{ drawEdges(); positionToolbar(); });
  </script>
</body>
</html>
