<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Editor visual de flujo</title>
  <style>
    :root {
      --bg: #f6f7fb; --card: #fff; --text: #222; --muted: #666; --primary: #0b5ed7; --green:#198754; --red:#dc3545;
    }
    * { box-sizing: border-box; }
    body { margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { padding: 14px 20px; background: #5b2a86; color:#fff; display:flex; align-items:center; justify-content:space-between; }
    header .actions { display:flex; gap:8px; align-items:center; }
    .btn { padding:8px 12px; border-radius:8px; border:0; cursor:pointer; color:#fff; font-weight:600; }
    .btn.save { background: var(--green); }
    .btn.reload { background: var(--primary); }
  .btn.add { background: #7444a8; }
    .btn.del { background: var(--red); }
  .status-chip { font-size:12px; padding:2px 6px; border-radius:6px; color:#fff; margin-left:8px; }
  .status-chip.on { background:#198754; }
  .status-chip.off { background:#6c757d; }
    .wrap { display:grid; grid-template-columns: 260px 1fr; gap:12px; padding: 12px; height: calc(100vh - 60px); }
    .sidebar { background: var(--card); border-radius:12px; padding:10px; overflow:auto; box-shadow: 0 6px 16px rgba(0,0,0,.06); }
    .sidebar h3 { margin:6px 6px 10px; }
    .sidebar .node-item { display:flex; align-items:center; justify-content:space-between; padding:6px 8px; border-radius:8px; margin:4px 0; background:#fafafa; }
    .sidebar .node-item input { width: 120px; padding:4px 6px; }
    .sidebar .node-item button { padding:4px 8px; border-radius:6px; border:0; cursor:pointer; }
    .canvas { position:relative; background:#f0f2f7; border-radius:12px; overflow:auto; box-shadow: 0 6px 16px rgba(0,0,0,.06); }
    /* Contenedor de zoom */
    .stage { position:relative; width: 1200px; height: 800px; }
    .stage-inner { position:relative; transform-origin: 0 0; }
  .nodes { position:relative; padding:20px; min-width: 1200px; min-height: 800px; }
  .node { position:absolute; width: 300px; background:var(--card); border-radius:12px; padding:10px; box-shadow: 0 6px 16px rgba(0,0,0,.08); border:1px solid #e8e8f0; }
  .node .head { display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px; }
    .node .head input[type="text"] { flex:1; font-weight:700; padding:6px 8px; border:1px solid #ddd; border-radius:8px; }
    .node .head .start { font-size:12px; color:#fff; background:#ff7a59; padding:2px 6px; border-radius:6px; }
  .node .head .drag { cursor:move; user-select:none; padding:2px 6px; color:#888; }
    .node textarea { width:100%; min-height: 80px; padding:8px; border:1px solid #ddd; border-radius:8px; font-size:14px; }
    .btns { margin-top:6px; }
  .btns .row { display:grid; grid-template-columns: 1fr 26px auto; gap:6px; align-items:center; margin-bottom:6px; }
    .btns input, .btns select { padding:6px 8px; border:1px solid #ddd; border-radius:8px; }
    .btns .row .delbtn { background: var(--red); color:#fff; border:0; border-radius:8px; padding:6px 8px; cursor:pointer; }
    .btns .addRow { background: var(--primary); color:#fff; border:0; border-radius:8px; padding:6px 8px; cursor:pointer; }
    .legend { font-size:12px; color:var(--muted); margin-top:4px; }
  svg.lines { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:2; }
  .nodes { position:relative; padding:20px; min-width: 1200px; min-height: 800px; z-index:1; }
    .edge { stroke:#8a8aa8; stroke-width:2; marker-end: url(#arrow); }
  .connector { width:14px; height:14px; border-radius:50%; border:2px solid #7444a8; background:#fff; display:inline-block; }
  .connector:hover { background:#e7dbff; }
  .inlet { width:10px; height:10px; border-radius:50%; border:2px solid #8a8aa8; background:#fff; display:inline-block; margin-right:6px; }
  .preview { stroke:#7444a8; stroke-width:2; fill:none; stroke-dasharray:4 4; }
  .start-connector { position:absolute; bottom:10px; right:10px; width:14px; height:14px; border-radius:50%; border:2px solid #7444a8; background:#fff; }
  .start-connector:hover { background:#e7dbff; }
  /* Conector de nodo acci√≥n (para flujos sin botones) */
  .node-connector { position:absolute; bottom:10px; right:10px; width:14px; height:14px; border-radius:50%; border:2px solid #7444a8; background:#fff; }
  .node-connector:hover { background:#e7dbff; }
  /* Assets UI */
  .assets { background:#fafbff; border:1px dashed #cfd4ff; padding:8px; border-radius:10px; margin-top:8px; }
  .assets .actions { display:flex; gap:8px; margin-bottom:6px; }
  .assets .actions button { background:#7444a8; color:#fff; border:0; border-radius:8px; padding:6px 8px; cursor:pointer; }
  .assets .list { display:flex; flex-direction:column; gap:6px; }
  .asset-item { display:flex; align-items:center; gap:8px; background:#fff; border:1px solid #eee; border-radius:8px; padding:6px; }
  .asset-item img { max-height:38px; border-radius:6px; }
  .asset-item .name { flex:1; font-size:13px; color:#333; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .asset-item button { background:var(--red); color:#fff; border:0; border-radius:8px; padding:4px 8px; cursor:pointer; }
  /* Zoom HUD */
  .zoom-hud { position:absolute; right:10px; bottom:10px; background:rgba(0,0,0,.6); color:#fff; padding:6px 8px; border-radius:8px; font-size:12px; z-index:3; }
    /* Overlay para elegir tipo de nodo */
    .overlay { position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:9999; }
    .overlay .panel { background:#fff; border-radius:12px; padding:16px; width:340px; box-shadow:0 8px 28px rgba(0,0,0,.25); }
    .overlay .panel h4 { margin:0 0 10px; }
    .overlay .choices { display:flex; flex-direction:column; gap:8px; }
    .overlay .choices button { padding:10px; border-radius:10px; border:1px solid #ddd; cursor:pointer; text-align:left; }
    .type-badge { font-size:12px; color:#fff; background:#6c757d; padding:2px 6px; border-radius:6px; margin-left:6px; }
  </style>
</head>
<body>
  <header>
    <div>
      <strong>Editor visual de flujo</strong>
      <span style="font-size:12px; opacity:.9; margin-left:8px;">(m√°x. 3 botones por nodo)</span>
  <span id="statusChip" class="status-chip off">Inactivo</span>
    </div>
    <div class="actions">
      <button class="btn reload" onclick="reloadFromServer()">‚Üª Recargar</button>
      <button class="btn save" onclick="saveFlow()">üíæ Guardar</button>
    </div>
  </header>

  <div class="wrap">
    <aside class="sidebar">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
        <h3 style="margin:0;">Nodos</h3>
  <button class="btn add" onclick="openAddNodeMenu()">+ A√±adir nodo</button>
      </div>
      <div style="margin-top:8px;">
        <label style="font-size:12px; color:var(--muted)">Nodo inicial</label>
        <select id="startNode" style="width:100%; padding:6px 8px; border:1px solid #ddd; border-radius:8px;"></select>
      </div>
      <div id="nodeList" style="margin-top:10px;"></div>
      <p class="legend">Tips:
        <br>‚Ä¢ Arrastra el circulito hacia otra caja para conectar ese bot√≥n.
        <br>‚Ä¢ Las flechas aparecen solo cuando el bot√≥n est√° conectado a otro nodo.
      </p>
    </aside>

    <section class="canvas">
      <div class="stage" id="stage">
        <div class="stage-inner" id="stageInner">
          <svg class="lines"></svg>
          <div class="nodes" id="nodes"></div>
        </div>
      </div>
      <div class="zoom-hud" id="zoomHud">100% (Ctrl + rueda)</div>
    </section>
  </div>

  <form id="saveForm" method="post" action="/flow?key={{ key }}" style="display:none;">
    <input type="hidden" name="content" id="contentField" />
  </form>

  <div id="toast" style="position:fixed; left:50%; transform:translateX(-50%); bottom:20px; background:#1e7e34; color:#fff; padding:10px 14px; border-radius:10px; box-shadow:0 6px 16px rgba(0,0,0,.2); font-weight:600; display:none; z-index:10000;">
    ‚úÖ Flujo guardado correctamente.
  </div>

  <div id="overlay" class="overlay">
    <div class="panel">
      <h4>Nuevo nodo</h4>
      <div class="choices">
        <button onclick="addNodeOfType('action')">Acci√≥n (mensaje + botones)</button>
        <button onclick="addNodeOfType('advisor')">Conversar con asesor (n√∫mero WhatsApp)</button>
        <button onclick="addNodeOfType('start')">Inicio (palabras clave)</button>
      </div>
      <div style="text-align:right; margin-top:10px;"><button class="btn del" onclick="closeAddNodeMenu()">Cerrar</button></div>
    </div>
  </div>

  <script>
    const FLOW_LIMIT = 3;
    let flow = {{ flow|tojson }};
  if (!flow || typeof flow !== 'object') flow = { start_node: null, nodes: {} };
    // Defaults para links (inyectados desde el backend)
    const DEFAULT_LINKS = {
      web: {{ (store_url or '')|tojson }},
      fb: {{ (fb_url or '')|tojson }},
      ig: {{ (ig_url or '')|tojson }},
      tiktok: {{ (tiktok_url or '')|tojson }}
    };

  const nodesEl = document.getElementById('nodes');
    const linesSvg = document.querySelector('svg.lines');
    const canvasEl = document.querySelector('.canvas');
    const stageEl = document.getElementById('stage');
    const stageInner = document.getElementById('stageInner');
    const zoomHud = document.getElementById('zoomHud');
    const startNodeSel = document.getElementById('startNode');
    const nodeListEl = document.getElementById('nodeList');
  let dragging = null; // { id, el, dx, dy }
  const overlay = document.getElementById('overlay');
  let ZOOM = 1.0; const MIN_ZOOM=0.5, MAX_ZOOM=2.0;

    function uid(base){
      let n = 1; let id = base || 'node';
      while(flow.nodes[id]) { id = (base||'node') + '_' + (++n); }
      return id;
    }

    function ensureDefaults(){
      if (typeof flow.enabled !== 'boolean') flow.enabled = true;
      if (!flow.nodes) flow.nodes = {};
      // Si no hay nodos, crear flujo base m√≠nimo: inicio -> welcome
      if (Object.keys(flow.nodes).length === 0) {
        flow.nodes = {
          'start': {
            type: 'start',
            keywords: 'hola, holi, buenas',
            next: 'welcome',
            pos: { x: 40, y: 40 }
          },
          'welcome': {
            type: 'action',
            text: 'üëã Hola, soy Fanty, tu asistente virtual. ¬°Bienvenida!',
            buttons: [],
            pos: { x: 420, y: 40 }
          }
        };
        flow.start_node = 'start';
      }
      flow.start_node = flow.start_node || Object.keys(flow.nodes)[0] || null;
      for (const k of Object.keys(flow.nodes)) {
        flow.nodes[k].text = flow.nodes[k].text || '';
        flow.nodes[k].buttons = (flow.nodes[k].buttons || []).slice(0, FLOW_LIMIT);
        flow.nodes[k].type = flow.nodes[k].type || 'action';
      }
    }
  updateStatusChip();
    function renderAll(){
      ensureDefaults();
      
      // Sidebar list
      startNodeSel.innerHTML = '';
      Object.keys(flow.nodes).forEach(id => {
        const opt = document.createElement('option');
        opt.value = id; opt.textContent = id; startNodeSel.appendChild(opt);
      });
      startNodeSel.value = flow.start_node || '';

      nodeListEl.innerHTML = '';
      Object.keys(flow.nodes).forEach(id => nodeListEl.appendChild(renderNodeListItem(id)));

      // Canvas nodes
      nodesEl.innerHTML = '';
  let i=0;
      const cols = 3; const gapX=360, gapY=220; // simple auto-grid
      Object.entries(flow.nodes).forEach(([id, node]) => {
        // Si el nodo no tiene posici√≥n, asignar una por grilla y guardarla
        if (!node.pos || typeof node.pos.x !== 'number' || typeof node.pos.y !== 'number') {
          const x = (i % cols) * gapX + 40;
          const y = Math.floor(i / cols) * gapY + 40;
          node.pos = { x, y };
        }
        nodesEl.appendChild(renderNodeCard(id, node, node.pos.x, node.pos.y));
        i++;
      });

      updateStageSize();
      drawEdges();
      window.setTimeout(drawEdges, 50);
    }

    function renderNodeListItem(id){
  const wrap = document.createElement('div');
      wrap.className = 'node-item';
      const inp = document.createElement('input');
      inp.value = id; inp.title = 'ID del nodo';
      inp.addEventListener('change', () => renameNode(id, inp.value.trim()));
      const del = document.createElement('button');
      del.textContent = 'üóëÔ∏è'; del.className='btn del';
      del.onclick = () => { deleteNode(id); };
      wrap.appendChild(inp); wrap.appendChild(del);
      return wrap;
    }

    function renderNodeCard(id, node, x, y){
  const el = document.createElement('div');
      el.className = 'node'; el.style.left = x+'px'; el.style.top = y+'px';
      el.dataset.nodeId = id;
      el.innerHTML = '';

      const head = document.createElement('div'); head.className='head';
      const drag = document.createElement('span'); drag.className='drag'; drag.textContent='‚†ø'; drag.title='Arrastra para mover';
      head.appendChild(drag);
  const title = document.createElement('input'); title.type='text'; title.value = id; title.title='ID del nodo';
      title.addEventListener('change', () => renameNode(id, title.value.trim()));
  const inlet = document.createElement('span'); inlet.className='inlet'; inlet.title='Entrada de conexiones';
  head.appendChild(inlet);
  head.appendChild(title);
      const tBadge = document.createElement('span'); tBadge.className = 'type-badge'; tBadge.textContent = (node.type||'action'); head.appendChild(tBadge);
      if (flow.start_node === id) {
        const badge = document.createElement('span'); badge.textContent='inicio'; badge.className='start'; head.appendChild(badge);
      }
      el.appendChild(head);

      // Cuerpo seg√∫n tipo de nodo
      if ((node.type||'action') === 'advisor') {
        const phone = document.createElement('input'); phone.placeholder='+51xxxxxxxxx (solo d√≠gitos o con +)'; phone.value = node.phone||'';
        phone.style.width = '100%'; phone.style.marginBottom = '6px';
        phone.oninput = () => { flow.nodes[id].phone = phone.value.trim(); };
        el.appendChild(phone);
  const ta = document.createElement('textarea'); ta.value = node.text || 'Te estamos transfiriendo con una asesora humana. Un momento por favor.';
        ta.placeholder = 'Texto opcional que se enviar√°'; ta.addEventListener('input', () => { flow.nodes[id].text = ta.value; });
        el.appendChild(ta);
  // Timeout de inactividad (minutos)
  const trow = document.createElement('div'); trow.style.display='grid'; trow.style.gridTemplateColumns='1fr 100px'; trow.style.gap='8px'; trow.style.alignItems='center'; trow.style.margin='6px 0';
  const tlab = document.createElement('label'); tlab.textContent = 'Cerrar por inactividad (min)'; tlab.style.fontSize='13px'; tlab.style.color='#333';
  const tnum = document.createElement('input'); tnum.type='number'; tnum.min='1'; tnum.max='720'; tnum.value = (node.timeout_min||node.human_timeout_min||15);
  tnum.oninput = ()=>{ const v = parseInt(tnum.value||'15',10); flow.nodes[id].timeout_min = isNaN(v)?15:Math.max(1, Math.min(720, v)); };
  trow.appendChild(tlab); trow.appendChild(tnum); el.appendChild(trow);
        // Links configurables (web y redes) con switches y URLs
        const linksBox = document.createElement('div'); linksBox.className='assets';
        const title = document.createElement('div'); title.style.fontWeight='700'; title.style.marginBottom='6px'; title.textContent='Links a mostrar mientras espera';
        linksBox.appendChild(title);
        const list = document.createElement('div'); list.style.display='flex'; list.style.flexDirection='column'; list.style.gap='6px';
        // Inicializar links del nodo si no existen
        const initIfNeeded = () => {
          if (!flow.nodes[id].links) {
            flow.nodes[id].links = {
              web: { enabled: !!DEFAULT_LINKS.web, url: DEFAULT_LINKS.web||'' },
              fb: { enabled: !!DEFAULT_LINKS.fb, url: DEFAULT_LINKS.fb||'' },
              ig: { enabled: !!DEFAULT_LINKS.ig, url: DEFAULT_LINKS.ig||'' },
              tiktok: { enabled: !!DEFAULT_LINKS.tiktok, url: DEFAULT_LINKS.tiktok||'' },
            };
            if (typeof flow.nodes[id].include_links === 'boolean') {
              const on = !!flow.nodes[id].include_links;
              Object.keys(flow.nodes[id].links).forEach(k => flow.nodes[id].links[k].enabled = on && !!flow.nodes[id].links[k].url);
            }
          }
        };
        initIfNeeded();

        const mkRow = (key, label) => {
          const row = document.createElement('div'); row.style.display='grid'; row.style.gridTemplateColumns='22px 1fr'; row.style.gap='8px'; row.style.alignItems='center';
          const chk = document.createElement('input'); chk.type='checkbox'; chk.checked = !!(flow.nodes[id].links?.[key]?.enabled);
          chk.onchange = () => { if (!flow.nodes[id].links) flow.nodes[id].links={}; if (!flow.nodes[id].links[key]) flow.nodes[id].links[key]={}; flow.nodes[id].links[key].enabled = !!chk.checked; syncIncludeLinks(); };
          const url = document.createElement('input'); url.placeholder = label + ' URL'; url.value = (flow.nodes[id].links?.[key]?.url || ''); url.style.width='100%';
          url.oninput = () => { if (!flow.nodes[id].links) flow.nodes[id].links={}; if (!flow.nodes[id].links[key]) flow.nodes[id].links[key]={}; flow.nodes[id].links[key].url = url.value.trim(); };
          row.appendChild(chk); row.appendChild(url);
          return row;
        };
        const syncIncludeLinks = () => {
          const l = flow.nodes[id].links || {};
          const anyOn = ['web','fb','ig','tiktok'].some(k => !!(l[k]?.enabled));
          flow.nodes[id].include_links = anyOn;
        };
        list.appendChild(mkRow('web', 'Web'));
        list.appendChild(mkRow('fb', 'Facebook'));
        list.appendChild(mkRow('ig', 'Instagram'));
        list.appendChild(mkRow('tiktok', 'TikTok'));
        const hint = document.createElement('div'); hint.className='legend'; hint.textContent='Activa/desactiva y edita las URLs que quieras mostrar.';
        linksBox.appendChild(list); linksBox.appendChild(hint);
        el.appendChild(linksBox);
      } else if ((node.type||'action') === 'start') {
        // Nota para palabras clave (sin textarea)
        const note = document.createElement('div'); note.className='legend';
        note.textContent = 'Escriba las palabras clave. Este nodo inicia el flujo.';
        el.appendChild(note);
      } else {
        const ta = document.createElement('textarea'); ta.value = node.text || '';
        ta.placeholder = 'Texto del mensaje'; ta.addEventListener('input', () => { flow.nodes[id].text = ta.value; });
        el.appendChild(ta);
      }

      if ((node.type||'action') === 'start') {
        // Toggle de encendido/apagado global del flujo
        const toggleWrap = document.createElement('div'); toggleWrap.style.display='flex'; toggleWrap.style.alignItems='center'; toggleWrap.style.gap='8px'; toggleWrap.style.margin='4px 0 6px';
        const toggle = document.createElement('input'); toggle.type='checkbox'; toggle.checked = !!flow.enabled; toggle.id = `en_${id}`;
        toggle.onchange = () => { flow.enabled = !!toggle.checked; updateStatusChip(); };
        const tl = document.createElement('label'); tl.setAttribute('for', `en_${id}`); tl.textContent = 'Flujo activo'; tl.style.fontSize='13px'; tl.style.color='#333';
        toggleWrap.appendChild(toggle); toggleWrap.appendChild(tl); el.appendChild(toggleWrap);

        const kw = document.createElement('input'); kw.placeholder='Palabras clave separadas por coma (hola, holi, buenas)'; kw.value = (node.keywords||'');
        kw.style.width = '100%'; kw.oninput = () => { flow.nodes[id].keywords = kw.value; };
        el.appendChild(kw);

        // Frases exactas (una por l√≠nea) para activar desde links con texto predefinido
        const ex = document.createElement('textarea');
        ex.placeholder = 'Frases exactas (una por l√≠nea) ‚Äî para links wa.me?text=...';
        ex.value = node.exact || '';
        ex.style.minHeight = '60px';
        ex.addEventListener('input', () => { flow.nodes[id].exact = ex.value; });
        el.appendChild(ex);

        // Conector √∫nico para salida del nodo de inicio
        const sc = document.createElement('span'); sc.className='start-connector'; sc.title='Arrastra para conectar el inicio con otro nodo';
        sc.dataset.startConnector = id;
        sc.addEventListener('mousedown', (e) => startConnect(e, id, null, sc));
        el.appendChild(sc);
      }

      if ((node.type||'action') !== 'advisor' && (node.type||'action') !== 'start') {
        // Zona de assets (imagenes/documentos)
        const assets = document.createElement('div'); assets.className='assets';
        const actions = document.createElement('div'); actions.className='actions';
        const addFile = document.createElement('button'); addFile.textContent='Agregar archivo';
        addFile.onclick = (ev) => { ev.preventDefault(); handleUpload(id, 'application/pdf', 'file'); };
        const addImg = document.createElement('button'); addImg.textContent='Agregar foto';
        addImg.onclick = (ev) => { ev.preventDefault(); handleUpload(id, 'image/*', 'image'); };
        actions.appendChild(addFile); actions.appendChild(addImg); assets.appendChild(actions);
        const list = document.createElement('div'); list.className='list';
        (node.assets||[]).forEach((a, ai) => {
          const item = document.createElement('div'); item.className='asset-item';
          if (a.type==='image') {
            const img = document.createElement('img'); img.src = a.url; img.alt=a.name||'imagen'; item.appendChild(img);
          } else {
            const ic = document.createElement('span'); ic.textContent='üìÑ'; item.appendChild(ic);
          }
          const name = document.createElement('a'); name.href=a.url; name.target='_blank'; name.className='name'; name.textContent=a.name||a.url; item.appendChild(name);
          const rm = document.createElement('button'); rm.textContent='Quitar'; rm.onclick = (ev)=>{ ev.preventDefault(); removeAsset(id, ai); };
          item.appendChild(rm);
          list.appendChild(item);
        });
        const help = document.createElement('div'); help.className='legend'; help.textContent='Se env√≠an antes del texto. Admite PDF, JPG, PNG.';
        assets.appendChild(list); assets.appendChild(help);
        el.appendChild(assets);
        const btns = document.createElement('div'); btns.className='btns';
        (node.buttons||[]).forEach((b, idx) => btns.appendChild(renderButtonRow(id, b, idx)));
        const add = document.createElement('button'); add.className='addRow'; add.textContent='+ A√±adir bot√≥n';
        add.onclick = () => { addButton(id); };
        btns.appendChild(add);
        el.appendChild(btns);

        // Conector inferior derecho para enlazar siguiente nodo cuando no hay botones
        const nc = document.createElement('span'); nc.className='node-connector'; nc.title='Arrastra para conectar este nodo con otro (flujo lineal)';
        nc.dataset.nodeConnector = id;
        nc.addEventListener('mousedown', (e) => startConnect(e, id, null, nc));
        el.appendChild(nc);
      }

      // Drag & drop por la cabecera (manilla)
      drag.addEventListener('mousedown', (e) => startDrag(e, el, id));

      return el;
    }

    function renderButtonRow(nodeId, b, idx){
      const row = document.createElement('div'); row.className='row';
      const title = document.createElement('input'); title.placeholder='T√≠tulo'; title.value = b.title || '';
      title.oninput = () => { flow.nodes[nodeId].buttons[idx].title = title.value; refresh(); };
      // Conector visual (drag para enlazar otro nodo)
      const connector = document.createElement('span'); connector.className='connector'; connector.title='Arrastra a otra caja para conectar';
      connector.dataset.connector = `${nodeId}:${idx}`;
      connector.addEventListener('mousedown', (e) => startConnect(e, nodeId, idx, connector));

      const del = document.createElement('button'); del.className='delbtn'; del.textContent='Quitar';
      del.onclick = () => { removeButton(nodeId, idx); };
      row.appendChild(title); row.appendChild(connector); row.appendChild(del);
      return row;
    }

    function openAddNodeMenu(){ overlay.style.display='flex'; }
    function closeAddNodeMenu(){ overlay.style.display='none'; }
    function addNodeOfType(type){
      const id = uid(type==='start' ? 'start' : (type==='advisor'?'advisor':'node'));
      const base = { type: type||'action', text: '', buttons: [], pos: null };
      if (type==='advisor') base.phone='';
      if (type==='start') base.keywords='hola, holi, buenas';
      flow.nodes[id] = base;
      if (type==='start') flow.start_node = id;
      if (!flow.start_node) flow.start_node = id;
      closeAddNodeMenu();
      refresh();
    }
    function deleteNode(id){
      if (!flow.nodes[id]) return;
      if (!confirm('¬øEliminar nodo '+id+'?')) return;
      delete flow.nodes[id];
      if (flow.start_node === id) flow.start_node = Object.keys(flow.nodes)[0] || null;
      // Quitar referencias next a este nodo
      for (const k of Object.keys(flow.nodes)) {
        const btns = flow.nodes[k].buttons||[];
        btns.forEach(b => { if (b.next === id) delete b.next; });
        // Quitar next desde nodos start
        if ((flow.nodes[k].type||'action') === 'start' && flow.nodes[k].next === id) {
          delete flow.nodes[k].next;
        }
      }
      refresh();
    }
    function renameNode(oldId, newId){
      if (!newId || newId===oldId || flow.nodes[newId]) { drawEdges(); return; }
      flow.nodes[newId] = flow.nodes[oldId]; delete flow.nodes[oldId];
      if (flow.start_node===oldId) flow.start_node=newId;
      for (const k of Object.keys(flow.nodes)) {
        (flow.nodes[k].buttons||[]).forEach(b => { if (b.next===oldId) b.next=newId; });
      }
      refresh();
    }
    function addButton(nodeId){
      const arr = flow.nodes[nodeId].buttons || (flow.nodes[nodeId].buttons=[]);
      if (arr.length >= FLOW_LIMIT) { alert('M√°ximo '+FLOW_LIMIT+' botones.'); return; }
      const first = Object.keys(flow.nodes)[0] || null;
      arr.push({ title: 'Opci√≥n', next: first });
      refresh();
    }
    function removeButton(nodeId, idx){
      const arr = flow.nodes[nodeId].buttons||[];
      arr.splice(idx, 1); refresh();
    }

    function refresh(){
      renderAll();
    }

    startNodeSel.addEventListener('change', () => {
      flow.start_node = startNodeSel.value || null; drawEdges();
    });

    function drawEdges(){
      // Limpia
      linesSvg.innerHTML = '<defs><marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#8a8aa8" /></marker></defs>';
      // Recalcular posiciones
      const host = stageInner.getBoundingClientRect();
      const nodeCards = Array.from(document.querySelectorAll('.node'));
      const pos = {};
      nodeCards.forEach(card => {
        const id = card.dataset.nodeId;
        const r = card.getBoundingClientRect();
        pos[id] = { x: (r.left - host.left)/ZOOM, y: (r.top - host.top)/ZOOM, w: r.width/ZOOM, h: r.height/ZOOM };
      });
      // Posiciones de conectores (por bot√≥n)
      const connPos = {};
      document.querySelectorAll('[data-connector]').forEach(el => {
        const r = el.getBoundingClientRect();
        connPos[el.dataset.connector] = { x: (r.left - host.left + r.width/2)/ZOOM, y: (r.top - host.top + r.height/2)/ZOOM };
      });
      // Posici√≥n de entrada por nodo (inlet)
      const inletPos = {};
      nodeCards.forEach(card => {
        const inlet = card.querySelector('.inlet');
        if (inlet) {
          const r = inlet.getBoundingClientRect();
          inletPos[card.dataset.nodeId] = { x: (r.left - host.left + r.width/2)/ZOOM, y: (r.top - host.top + r.height/2)/ZOOM };
        }
      });
      // Posici√≥n del conector de inicio por nodo
      const startConnPos = {};
      document.querySelectorAll('[data-start-connector]').forEach(el => {
        const r = el.getBoundingClientRect();
        startConnPos[el.dataset.startConnector] = { x: (r.left - host.left + r.width/2)/ZOOM, y: (r.top - host.top + r.height/2)/ZOOM };
      });
      // Posici√≥n del conector de nodo acci√≥n
      const nodeConnPos = {};
      document.querySelectorAll('[data-node-connector]').forEach(el => {
        const r = el.getBoundingClientRect();
        nodeConnPos[el.dataset.nodeConnector] = { x: (r.left - host.left + r.width/2)/ZOOM, y: (r.top - host.top + r.height/2)/ZOOM };
      });
      // Pintar l√≠neas next
      Object.entries(flow.nodes).forEach(([id, node]) => {
        (node.buttons||[]).forEach((b, idx) => {
          if (!b.next || !pos[id] || !pos[b.next]) return;
          const p1 = connPos[`${id}:${idx}`];
          const p2 = inletPos[b.next] || { x: pos[b.next].x, y: pos[b.next].y + pos[b.next].h/2 };
          if (!p1 || !p2) return;
          const x1 = p1.x, y1 = p1.y;
          const x2 = p2.x, y2 = p2.y;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2;
          const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d);
          // Atributos directos para compatibilidad en todos los navegadores
          path.setAttribute('class','edge');
          path.setAttribute('fill','none');
          path.setAttribute('stroke','#8a8aa8');
          path.setAttribute('stroke-width','2');
          path.setAttribute('marker-end','url(#arrow)');
          linesSvg.appendChild(path);
        });
        // Edge desde nodo start (si existe next)
        if ((node.type||'action') === 'start' && node.next && startConnPos[id] && inletPos[node.next]) {
          const p1 = startConnPos[id];
          const p2 = inletPos[node.next];
          const x1 = p1.x, y1 = p1.y; const x2 = p2.x, y2 = p2.y;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2; const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d); path.setAttribute('class','edge'); path.setAttribute('fill','none'); path.setAttribute('stroke','#8a8aa8'); path.setAttribute('stroke-width','2'); path.setAttribute('marker-end','url(#arrow)'); linesSvg.appendChild(path);
        }
        // Edge desde nodo action (si existe next)
        if ((node.type||'action') === 'action' && node.next && nodeConnPos[id] && inletPos[node.next]) {
          const p1 = nodeConnPos[id];
          const p2 = inletPos[node.next];
          const x1 = p1.x, y1 = p1.y; const x2 = p2.x, y2 = p2.y;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2; const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d); path.setAttribute('class','edge'); path.setAttribute('fill','none'); path.setAttribute('stroke','#8a8aa8'); path.setAttribute('stroke-width','2'); path.setAttribute('marker-end','url(#arrow)'); linesSvg.appendChild(path);
        }
      });
    }

    // Conexi√≥n visual (drag desde el conector a otro nodo)
  let connecting = null; // { nodeId, idx|null, x0, y0, preview }
    function startConnect(e, nodeId, idx, connectorEl){
      e.preventDefault();
      const rect = connectorEl.getBoundingClientRect();
      const host = stageInner.getBoundingClientRect();
      const x0 = (rect.left - host.left + rect.width/2)/ZOOM;
      const y0 = (rect.top - host.top + rect.height/2)/ZOOM;
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('class','preview');
      linesSvg.appendChild(p);
  connecting = { nodeId, idx, x0, y0, preview: p };
      document.addEventListener('mousemove', onConnectMove);
      document.addEventListener('mouseup', endConnect);
    }
    function onConnectMove(e){
      if (!connecting) return;
      const host = stageInner.getBoundingClientRect();
      const x1 = (e.clientX - host.left)/ZOOM; const y1 = (e.clientY - host.top)/ZOOM;
      const mx = (connecting.x0 + x1)/2;
      const d = `M ${connecting.x0} ${connecting.y0} C ${mx} ${connecting.y0}, ${mx} ${y1}, ${x1} ${y1}`;
      connecting.preview.setAttribute('d', d);
    }
    function endConnect(e){
      document.removeEventListener('mousemove', onConnectMove);
      document.removeEventListener('mouseup', endConnect);
      if (!connecting) return;
      // Buscar nodo bajo el puntero
      const el = document.elementFromPoint(e.clientX, e.clientY);
      let card = el;
      while (card && !card.classList?.contains('node')) card = card.parentElement;
      if (card && card.dataset.nodeId) {
        const target = card.dataset.nodeId;
        if (connecting.idx === null) {
          // Conexi√≥n desde nodo de inicio
          flow.nodes[connecting.nodeId].next = target;
        } else {
          const btns = flow.nodes[connecting.nodeId].buttons || [];
          btns[connecting.idx] = { title: btns[connecting.idx]?.title || 'Opci√≥n', next: target };
          flow.nodes[connecting.nodeId].buttons = btns;
        }
      }
      // limpiar preview
      if (connecting.preview && connecting.preview.parentNode) connecting.preview.parentNode.removeChild(connecting.preview);
      connecting = null;
      refresh();
    }

    function startDrag(e, el, id){
      e.preventDefault();
      const r = el.getBoundingClientRect();
      dragging = { id, el, offsetX: (e.clientX - r.left)/ZOOM, offsetY: (e.clientY - r.top)/ZOOM };
      document.addEventListener('mousemove', onDragMove);
      document.addEventListener('mouseup', endDrag);
    }
    function onDragMove(e){
      if (!dragging) return;
      const host = stageInner.getBoundingClientRect();
      let x = (e.clientX - host.left)/ZOOM - dragging.offsetX;
      let y = (e.clientY - host.top)/ZOOM - dragging.offsetY;
      // Limitar a valores no negativos
      x = Math.max(0, x); y = Math.max(0, y);
      dragging.el.style.left = x + 'px';
      dragging.el.style.top = y + 'px';
      const n = flow.nodes[dragging.id];
      if (n) n.pos = { x, y };
      drawEdges();
    }
    function endDrag(){
      document.removeEventListener('mousemove', onDragMove);
      document.removeEventListener('mouseup', endDrag);
      dragging = null;
    }

    function saveFlow(){
      // Normalizar botones a solo next o id
      for (const k of Object.keys(flow.nodes)) {
        // Mantener posici√≥n actual
        const card = nodesEl.querySelector(`.node[data-node-id="${k}"]`);
        if (card) {
          const left = parseInt(card.style.left || '0', 10);
          const top = parseInt(card.style.top || '0', 10);
          flow.nodes[k].pos = { x: left, y: top };
        }
        flow.nodes[k].buttons = (flow.nodes[k].buttons||[]).slice(0, FLOW_LIMIT).map(b => {
          const out = { title: b.title||'Opci√≥n' };
          if (b.next) out.next = b.next; else if (b.id) out.id = b.id.trim();
          return out;
        });
        // Asegurar type/phone/keywords/assets persisten
        flow.nodes[k].type = flow.nodes[k].type || 'action';
        if (flow.nodes[k].type==='advisor') {
          flow.nodes[k].phone = (flow.nodes[k].phone||'').trim();
          // Normalizar links
          const links = flow.nodes[k].links;
          const norm = {};
          ['web','fb','ig','tiktok'].forEach(key => {
            const it = links && links[key] ? links[key] : null;
            if (it && (it.url||'').trim()) {
              norm[key] = { enabled: !!it.enabled, url: (it.url||'').trim() };
            }
          });
          if (Object.keys(norm).length > 0) {
            flow.nodes[k].links = norm;
            flow.nodes[k].include_links = Object.values(norm).some(v => v.enabled);
          } else {
            delete flow.nodes[k].links;
            flow.nodes[k].include_links = !!flow.nodes[k].include_links; // mantener compatibilidad
          }
          // Timeout por inactividad
          const tm = parseInt(flow.nodes[k].timeout_min||flow.nodes[k].human_timeout_min||15, 10);
          flow.nodes[k].timeout_min = isNaN(tm)?15:Math.max(1, Math.min(720, tm));
        }
        if (flow.nodes[k].type==='start') {
          flow.nodes[k].keywords = (flow.nodes[k].keywords||'').trim();
          const exact = (flow.nodes[k].exact||'').trim();
          if (exact) {
            flow.nodes[k].exact = exact;
          } else {
            delete flow.nodes[k].exact;
          }
          if (flow.nodes[k].next) flow.nodes[k].next = String(flow.nodes[k].next);
          // El nodo inicio no usa texto; limpiarlo si existe
          if ('text' in flow.nodes[k]) delete flow.nodes[k].text;
        }
        if (!Array.isArray(flow.nodes[k].assets)) delete flow.nodes[k].assets; // solo guardar si existe bien formada
      }
  const payload = JSON.stringify(flow, null, 2);
      // Guardar por fetch JSON para no salir del builder
      const fd = new FormData();
      fd.append('content', payload);
      fetch('/flow?key={{ key }}&format=json', { method: 'POST', body: fd })
        .then(async (r) => {
          if (!r.ok) throw new Error((await r.json()).error || 'Error al guardar');
          return r.json();
        })
        .then(() => showToast('‚úÖ Flujo guardado correctamente.'))
        .catch(err => showToast('‚ùå Error al guardar: ' + err.message, true));
    }

    function reloadFromServer(){
      window.location.reload();
    }

    function showToast(msg, isError){
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.style.background = isError ? '#dc3545' : '#1e7e34';
      t.style.display = 'block';
      clearTimeout(window.__toastTimer);
      window.__toastTimer = setTimeout(() => { t.style.display = 'none'; }, 2000);
    }

    function updateStatusChip(){
      const chip = document.getElementById('statusChip');
      if (!chip) return;
      const on = !!(flow && flow.enabled);
      chip.textContent = on ? 'Activo' : 'Inactivo';
      chip.classList.toggle('on', on);
      chip.classList.toggle('off', !on);
    }

    // Upload helpers
    async function handleUpload(nodeId, accept, kind){
      try {
        const input = document.createElement('input'); input.type='file'; input.accept = accept;
        const picked = await new Promise((resolve) => { input.onchange = () => resolve(input.files && input.files[0]); input.click(); });
        if (!picked) return;
        const fd = new FormData(); fd.append('file', picked);
        const res = await fetch('/internal/upload?key={{ key }}', { method:'POST', body: fd });
        if (!res.ok) { alert('Error al subir archivo'); return; }
        const data = await res.json();
        if (!flow.nodes[nodeId].assets) flow.nodes[nodeId].assets = [];
        flow.nodes[nodeId].assets.push({ type: kind, url: data.url, name: data.name || picked.name });
        refresh();
      } catch (err) {
        console.error(err); alert('No se pudo subir el archivo.');
      }
    }
    function removeAsset(nodeId, idx){
      const arr = flow.nodes[nodeId].assets||[]; arr.splice(idx,1); refresh();
    }

    // Zoom helpers
    function setZoom(nextZoom, pivotClientX, pivotClientY){
      const old = ZOOM; const nz = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, nextZoom));
      if (Math.abs(nz - old) < 0.001) return;
      // Mantener foco bajo el cursor
      const rect = canvasEl.getBoundingClientRect();
      const px = (pivotClientX ?? (rect.left + rect.width/2)) - rect.left + canvasEl.scrollLeft;
      const py = (pivotClientY ?? (rect.top + rect.height/2)) - rect.top + canvasEl.scrollTop;
      const worldX = px / old; const worldY = py / old;

      ZOOM = nz;
      updateStageSize();
      drawEdges();

      const newPx = worldX * ZOOM;
      const newPy = worldY * ZOOM;
      canvasEl.scrollLeft = newPx - ((pivotClientX ?? (rect.left + rect.width/2)) - rect.left);
      canvasEl.scrollTop = newPy - ((pivotClientY ?? (rect.top + rect.height/2)) - rect.top);
      zoomHud.textContent = Math.round(ZOOM*100) + '% (Ctrl + rueda)';
    }
    function updateStageSize(){
      // calcular mundo seg√∫n DOM real (m√°s preciso con textareas/botones)
      let maxX = 1200, maxY = 800;
      const host = stageInner.getBoundingClientRect();
      const cards = Array.from(document.querySelectorAll('.node'));
      cards.forEach(card => {
        const r = card.getBoundingClientRect();
        const right = (r.right - host.left)/ZOOM;
        const bottom = (r.bottom - host.top)/ZOOM;
        maxX = Math.max(maxX, right + 200);
        maxY = Math.max(maxY, bottom + 200);
      });
      stageEl.style.width = (maxX * ZOOM) + 'px';
      stageEl.style.height = (maxY * ZOOM) + 'px';
      stageInner.style.width = maxX + 'px';
      stageInner.style.height = maxY + 'px';
      stageInner.style.transform = `scale(${ZOOM})`;
    }

    canvasEl.addEventListener('wheel', (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        setZoom(ZOOM * factor, e.clientX, e.clientY);
      }
    }, { passive:false });

    // Primer render
    renderAll();
    window.addEventListener('resize', drawEdges);
    // Redibujar al desplazar el lienzo
    canvasEl.addEventListener('scroll', drawEdges);
  </script>
</body>
</html>
