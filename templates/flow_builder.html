<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Editor visual de flujo</title>
  <style>
    :root {
      --bg: #f6f7fb; --card: #fff; --text: #222; --muted: #666; --primary: #0b5ed7; --green:#198754; --red:#dc3545;
    }
    * { box-sizing: border-box; }
    body { margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { padding: 14px 20px; background: #5b2a86; color:#fff; display:flex; align-items:center; justify-content:space-between; }
    header .actions { display:flex; gap:8px; align-items:center; }
    .btn { padding:8px 12px; border-radius:8px; border:0; cursor:pointer; color:#fff; font-weight:600; }
    .btn.save { background: var(--green); }
    .btn.reload { background: var(--primary); }
  .btn.add { background: #7444a8; }
    .btn.del { background: var(--red); }
    .wrap { display:grid; grid-template-columns: 260px 1fr; gap:12px; padding: 12px; height: calc(100vh - 60px); }
    .sidebar { background: var(--card); border-radius:12px; padding:10px; overflow:auto; box-shadow: 0 6px 16px rgba(0,0,0,.06); }
    .sidebar h3 { margin:6px 6px 10px; }
    .sidebar .node-item { display:flex; align-items:center; justify-content:space-between; padding:6px 8px; border-radius:8px; margin:4px 0; background:#fafafa; }
    .sidebar .node-item input { width: 120px; padding:4px 6px; }
    .sidebar .node-item button { padding:4px 8px; border-radius:6px; border:0; cursor:pointer; }
    .canvas { position:relative; background:#f0f2f7; border-radius:12px; overflow:auto; box-shadow: 0 6px 16px rgba(0,0,0,.06); }
  .nodes { position:relative; padding:20px; min-width: 1200px; min-height: 800px; }
  .node { position:absolute; width: 300px; background:var(--card); border-radius:12px; padding:10px; box-shadow: 0 6px 16px rgba(0,0,0,.08); border:1px solid #e8e8f0; }
  .node .head { display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px; }
    .node .head input[type="text"] { flex:1; font-weight:700; padding:6px 8px; border:1px solid #ddd; border-radius:8px; }
    .node .head .start { font-size:12px; color:#fff; background:#ff7a59; padding:2px 6px; border-radius:6px; }
  .node .head .drag { cursor:move; user-select:none; padding:2px 6px; color:#888; }
    .node textarea { width:100%; min-height: 80px; padding:8px; border:1px solid #ddd; border-radius:8px; font-size:14px; }
    .btns { margin-top:6px; }
  .btns .row { display:grid; grid-template-columns: 1fr 26px auto; gap:6px; align-items:center; margin-bottom:6px; }
    .btns input, .btns select { padding:6px 8px; border:1px solid #ddd; border-radius:8px; }
    .btns .row .delbtn { background: var(--red); color:#fff; border:0; border-radius:8px; padding:6px 8px; cursor:pointer; }
    .btns .addRow { background: var(--primary); color:#fff; border:0; border-radius:8px; padding:6px 8px; cursor:pointer; }
    .legend { font-size:12px; color:var(--muted); margin-top:4px; }
  svg.lines { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:2; }
  .nodes { position:relative; padding:20px; min-width: 1200px; min-height: 800px; z-index:1; }
    .edge { stroke:#8a8aa8; stroke-width:2; marker-end: url(#arrow); }
  .connector { width:14px; height:14px; border-radius:50%; border:2px solid #7444a8; background:#fff; display:inline-block; }
  .connector:hover { background:#e7dbff; }
  .inlet { width:10px; height:10px; border-radius:50%; border:2px solid #8a8aa8; background:#fff; display:inline-block; margin-right:6px; }
  .preview { stroke:#7444a8; stroke-width:2; fill:none; stroke-dasharray:4 4; }
  .start-connector { position:absolute; bottom:10px; right:10px; width:14px; height:14px; border-radius:50%; border:2px solid #7444a8; background:#fff; }
  .start-connector:hover { background:#e7dbff; }
    /* Overlay para elegir tipo de nodo */
    .overlay { position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:9999; }
    .overlay .panel { background:#fff; border-radius:12px; padding:16px; width:340px; box-shadow:0 8px 28px rgba(0,0,0,.25); }
    .overlay .panel h4 { margin:0 0 10px; }
    .overlay .choices { display:flex; flex-direction:column; gap:8px; }
    .overlay .choices button { padding:10px; border-radius:10px; border:1px solid #ddd; cursor:pointer; text-align:left; }
    .type-badge { font-size:12px; color:#fff; background:#6c757d; padding:2px 6px; border-radius:6px; margin-left:6px; }
  </style>
</head>
<body>
  <header>
    <div>
      <strong>Editor visual de flujo</strong>
      <span style="font-size:12px; opacity:.9; margin-left:8px;">(m√°x. 3 botones por nodo)</span>
    </div>
    <div class="actions">
      <button class="btn reload" onclick="reloadFromServer()">‚Üª Recargar</button>
      <button class="btn save" onclick="saveFlow()">üíæ Guardar</button>
    </div>
  </header>

  <div class="wrap">
    <aside class="sidebar">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
        <h3 style="margin:0;">Nodos</h3>
  <button class="btn add" onclick="openAddNodeMenu()">+ A√±adir nodo</button>
      </div>
      <div style="margin-top:8px;">
        <label style="font-size:12px; color:var(--muted)">Nodo inicial</label>
        <select id="startNode" style="width:100%; padding:6px 8px; border:1px solid #ddd; border-radius:8px;"></select>
      </div>
      <div id="nodeList" style="margin-top:10px;"></div>
      <p class="legend">Tips:
        <br>‚Ä¢ Arrastra el circulito hacia otra caja para conectar ese bot√≥n.
        <br>‚Ä¢ Las flechas aparecen solo cuando el bot√≥n est√° conectado a otro nodo.
      </p>
    </aside>

    <section class="canvas">
      <svg class="lines"></svg>
      <div class="nodes" id="nodes"></div>
    </section>
  </div>

  <form id="saveForm" method="post" action="/flow?key={{ key }}" style="display:none;">
    <input type="hidden" name="content" id="contentField" />
  </form>

  <div id="overlay" class="overlay">
    <div class="panel">
      <h4>Nuevo nodo</h4>
      <div class="choices">
        <button onclick="addNodeOfType('action')">Acci√≥n (mensaje + botones)</button>
        <button onclick="addNodeOfType('advisor')">Conversar con asesor (n√∫mero WhatsApp)</button>
        <button onclick="addNodeOfType('start')">Inicio (palabras clave)</button>
      </div>
      <div style="text-align:right; margin-top:10px;"><button class="btn del" onclick="closeAddNodeMenu()">Cerrar</button></div>
    </div>
  </div>

  <script>
    const FLOW_LIMIT = 3;
    let flow = {{ flow|tojson }};
    if (!flow || typeof flow !== 'object') flow = { start_node: null, nodes: {} };

  const nodesEl = document.getElementById('nodes');
    const linesSvg = document.querySelector('svg.lines');
    const canvasEl = document.querySelector('.canvas');
    const startNodeSel = document.getElementById('startNode');
    const nodeListEl = document.getElementById('nodeList');
  let dragging = null; // { id, el, dx, dy }
  const overlay = document.getElementById('overlay');

    function uid(base){
      let n = 1; let id = base || 'node';
      while(flow.nodes[id]) { id = (base||'node') + '_' + (++n); }
      return id;
    }

    function ensureDefaults(){
      flow.start_node = flow.start_node || Object.keys(flow.nodes)[0] || null;
      if (!flow.nodes) flow.nodes = {};
      for (const k of Object.keys(flow.nodes)) {
        flow.nodes[k].text = flow.nodes[k].text || '';
        flow.nodes[k].buttons = (flow.nodes[k].buttons || []).slice(0, FLOW_LIMIT);
        flow.nodes[k].type = flow.nodes[k].type || 'action';
      }
    }

    function renderAll(){
      ensureDefaults();
      // Sidebar list
      startNodeSel.innerHTML = '';
      Object.keys(flow.nodes).forEach(id => {
        const opt = document.createElement('option');
        opt.value = id; opt.textContent = id; startNodeSel.appendChild(opt);
      });
      startNodeSel.value = flow.start_node || '';

      nodeListEl.innerHTML = '';
      Object.keys(flow.nodes).forEach(id => nodeListEl.appendChild(renderNodeListItem(id)));

      // Canvas nodes
      nodesEl.innerHTML = '';
      let i=0;
      const cols = 3; const gapX=360, gapY=220; // simple auto-grid
      Object.entries(flow.nodes).forEach(([id, node]) => {
        // Si el nodo no tiene posici√≥n, asignar una por grilla y guardarla
        if (!node.pos || typeof node.pos.x !== 'number' || typeof node.pos.y !== 'number') {
          const x = (i % cols) * gapX + 40;
          const y = Math.floor(i / cols) * gapY + 40;
          node.pos = { x, y };
        }
        nodesEl.appendChild(renderNodeCard(id, node, node.pos.x, node.pos.y));
        i++;
      });

      drawEdges();
      window.setTimeout(drawEdges, 50);
    }

    function renderNodeListItem(id){
      const wrap = document.createElement('div');
      wrap.className = 'node-item';
      const inp = document.createElement('input');
      inp.value = id; inp.title = 'ID del nodo';
      inp.addEventListener('change', () => renameNode(id, inp.value.trim()));
      const del = document.createElement('button');
      del.textContent = 'üóëÔ∏è'; del.className='btn del';
      del.onclick = () => { deleteNode(id); };
      wrap.appendChild(inp); wrap.appendChild(del);
      return wrap;
    }

    function renderNodeCard(id, node, x, y){
      const el = document.createElement('div');
      el.className = 'node'; el.style.left = x+'px'; el.style.top = y+'px';
      el.dataset.nodeId = id;
      el.innerHTML = '';

      const head = document.createElement('div'); head.className='head';
      const drag = document.createElement('span'); drag.className='drag'; drag.textContent='‚†ø'; drag.title='Arrastra para mover';
      head.appendChild(drag);
  const title = document.createElement('input'); title.type='text'; title.value = id; title.title='ID del nodo';
      title.addEventListener('change', () => renameNode(id, title.value.trim()));
  const inlet = document.createElement('span'); inlet.className='inlet'; inlet.title='Entrada de conexiones';
  head.appendChild(inlet);
  head.appendChild(title);
      const tBadge = document.createElement('span'); tBadge.className = 'type-badge'; tBadge.textContent = (node.type||'action'); head.appendChild(tBadge);
      if (flow.start_node === id) {
        const badge = document.createElement('span'); badge.textContent='inicio'; badge.className='start'; head.appendChild(badge);
      }
      el.appendChild(head);

      // Cuerpo seg√∫n tipo de nodo
      if ((node.type||'action') === 'advisor') {
        const phone = document.createElement('input'); phone.placeholder='+51xxxxxxxxx (solo d√≠gitos o con +)'; phone.value = node.phone||'';
        phone.style.width = '100%'; phone.style.marginBottom = '6px';
        phone.oninput = () => { flow.nodes[id].phone = phone.value.trim(); };
        el.appendChild(phone);
        const ta = document.createElement('textarea'); ta.value = node.text || 'Te contacto con una asesora por WhatsApp.';
        ta.placeholder = 'Texto opcional que se enviar√°'; ta.addEventListener('input', () => { flow.nodes[id].text = ta.value; });
        el.appendChild(ta);
      } else {
        const ta = document.createElement('textarea'); ta.value = node.text || '';
        ta.placeholder = 'Texto del mensaje'; ta.addEventListener('input', () => { flow.nodes[id].text = ta.value; });
        el.appendChild(ta);
      }

      if ((node.type||'action') === 'start') {
        const kw = document.createElement('input'); kw.placeholder='Palabras clave separadas por coma (hola, holi, buenas)'; kw.value = (node.keywords||'');
        kw.style.width = '100%'; kw.oninput = () => { flow.nodes[id].keywords = kw.value; };
        el.appendChild(kw);
        // Conector √∫nico para salida del nodo de inicio
        const sc = document.createElement('span'); sc.className='start-connector'; sc.title='Arrastra para conectar el inicio con otro nodo';
        sc.dataset.startConnector = id;
        sc.addEventListener('mousedown', (e) => startConnect(e, id, null, sc));
        el.appendChild(sc);
      }

      if ((node.type||'action') !== 'advisor' && (node.type||'action') !== 'start') {
        const btns = document.createElement('div'); btns.className='btns';
        (node.buttons||[]).forEach((b, idx) => btns.appendChild(renderButtonRow(id, b, idx)));
        const add = document.createElement('button'); add.className='addRow'; add.textContent='+ A√±adir bot√≥n';
        add.onclick = () => { addButton(id); };
        btns.appendChild(add);
        el.appendChild(btns);
      }

      // Drag & drop por la cabecera (manilla)
      drag.addEventListener('mousedown', (e) => startDrag(e, el, id));

      return el;
    }

    function renderButtonRow(nodeId, b, idx){
      const row = document.createElement('div'); row.className='row';
      const title = document.createElement('input'); title.placeholder='T√≠tulo'; title.value = b.title || '';
      title.oninput = () => { flow.nodes[nodeId].buttons[idx].title = title.value; refresh(); };
      // Conector visual (drag para enlazar otro nodo)
      const connector = document.createElement('span'); connector.className='connector'; connector.title='Arrastra a otra caja para conectar';
      connector.dataset.connector = `${nodeId}:${idx}`;
      connector.addEventListener('mousedown', (e) => startConnect(e, nodeId, idx, connector));

      const del = document.createElement('button'); del.className='delbtn'; del.textContent='Quitar';
      del.onclick = () => { removeButton(nodeId, idx); };
      row.appendChild(title); row.appendChild(connector); row.appendChild(del);
      return row;
    }

    function openAddNodeMenu(){ overlay.style.display='flex'; }
    function closeAddNodeMenu(){ overlay.style.display='none'; }
    function addNodeOfType(type){
      const id = uid(type==='start' ? 'start' : (type==='advisor'?'advisor':'node'));
      const base = { type: type||'action', text: '', buttons: [], pos: null };
      if (type==='advisor') base.phone='';
      if (type==='start') base.keywords='hola, holi, buenas';
      flow.nodes[id] = base;
      if (type==='start') flow.start_node = id;
      if (!flow.start_node) flow.start_node = id;
      closeAddNodeMenu();
      refresh();
    }
    function deleteNode(id){
      if (!flow.nodes[id]) return;
      if (!confirm('¬øEliminar nodo '+id+'?')) return;
      delete flow.nodes[id];
      if (flow.start_node === id) flow.start_node = Object.keys(flow.nodes)[0] || null;
      // Quitar referencias next a este nodo
      for (const k of Object.keys(flow.nodes)) {
        const btns = flow.nodes[k].buttons||[];
        btns.forEach(b => { if (b.next === id) delete b.next; });
      }
      refresh();
    }
    function renameNode(oldId, newId){
      if (!newId || newId===oldId || flow.nodes[newId]) { drawEdges(); return; }
      flow.nodes[newId] = flow.nodes[oldId]; delete flow.nodes[oldId];
      if (flow.start_node===oldId) flow.start_node=newId;
      for (const k of Object.keys(flow.nodes)) {
        (flow.nodes[k].buttons||[]).forEach(b => { if (b.next===oldId) b.next=newId; });
      }
      refresh();
    }
    function addButton(nodeId){
      const arr = flow.nodes[nodeId].buttons || (flow.nodes[nodeId].buttons=[]);
      if (arr.length >= FLOW_LIMIT) { alert('M√°ximo '+FLOW_LIMIT+' botones.'); return; }
      const first = Object.keys(flow.nodes)[0] || null;
      arr.push({ title: 'Opci√≥n', next: first });
      refresh();
    }
    function removeButton(nodeId, idx){
      const arr = flow.nodes[nodeId].buttons||[];
      arr.splice(idx, 1); refresh();
    }

    function refresh(){
      renderAll();
    }

    startNodeSel.addEventListener('change', () => {
      flow.start_node = startNodeSel.value || null; drawEdges();
    });

    function drawEdges(){
      // Limpia
      linesSvg.innerHTML = '<defs><marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#8a8aa8" /></marker></defs>';
      // Recalcular posiciones
      const host = canvasEl.getBoundingClientRect();
      const nodeCards = Array.from(document.querySelectorAll('.node'));
      const pos = {};
      nodeCards.forEach(card => {
        const id = card.dataset.nodeId;
        const r = card.getBoundingClientRect();
        pos[id] = { x: r.left - host.left, y: r.top - host.top, w: r.width, h: r.height };
      });
      // Posiciones de conectores (por bot√≥n)
      const connPos = {};
      document.querySelectorAll('[data-connector]').forEach(el => {
        const r = el.getBoundingClientRect();
        connPos[el.dataset.connector] = { x: r.left - host.left + r.width/2, y: r.top - host.top + r.height/2 };
      });
      // Posici√≥n de entrada por nodo (inlet)
      const inletPos = {};
      nodeCards.forEach(card => {
        const inlet = card.querySelector('.inlet');
        if (inlet) {
          const r = inlet.getBoundingClientRect();
          inletPos[card.dataset.nodeId] = { x: r.left - host.left + r.width/2, y: r.top - host.top + r.height/2 };
        }
      });
      // Posici√≥n del conector de inicio por nodo
      const startConnPos = {};
      document.querySelectorAll('[data-start-connector]').forEach(el => {
        const r = el.getBoundingClientRect();
        startConnPos[el.dataset.startConnector] = { x: r.left - host.left + r.width/2, y: r.top - host.top + r.height/2 };
      });
      // Pintar l√≠neas next
      Object.entries(flow.nodes).forEach(([id, node]) => {
        (node.buttons||[]).forEach((b, idx) => {
          if (!b.next || !pos[id] || !pos[b.next]) return;
          const p1 = connPos[`${id}:${idx}`];
          const p2 = inletPos[b.next] || { x: pos[b.next].x, y: pos[b.next].y + pos[b.next].h/2 };
          if (!p1 || !p2) return;
          const x1 = p1.x, y1 = p1.y;
          const x2 = p2.x, y2 = p2.y;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2;
          const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d);
          // Atributos directos para compatibilidad en todos los navegadores
          path.setAttribute('class','edge');
          path.setAttribute('fill','none');
          path.setAttribute('stroke','#8a8aa8');
          path.setAttribute('stroke-width','2');
          path.setAttribute('marker-end','url(#arrow)');
          linesSvg.appendChild(path);
        });
        // Edge desde nodo start (si existe next)
        if ((node.type||'action') === 'start' && node.next && startConnPos[id] && inletPos[node.next]) {
          const p1 = startConnPos[id];
          const p2 = inletPos[node.next];
          const x1 = p1.x, y1 = p1.y; const x2 = p2.x, y2 = p2.y;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2; const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d); path.setAttribute('class','edge'); path.setAttribute('fill','none'); path.setAttribute('stroke','#8a8aa8'); path.setAttribute('stroke-width','2'); path.setAttribute('marker-end','url(#arrow)'); linesSvg.appendChild(path);
        }
      });
    }

    // Conexi√≥n visual (drag desde el conector a otro nodo)
  let connecting = null; // { nodeId, idx|null, x0, y0, preview }
    function startConnect(e, nodeId, idx, connectorEl){
      e.preventDefault();
      const rect = connectorEl.getBoundingClientRect();
      const host = canvasEl.getBoundingClientRect();
      const x0 = rect.left - host.left + rect.width/2;
      const y0 = rect.top - host.top + rect.height/2;
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('class','preview');
      linesSvg.appendChild(p);
  connecting = { nodeId, idx, x0, y0, preview: p };
      document.addEventListener('mousemove', onConnectMove);
      document.addEventListener('mouseup', endConnect);
    }
    function onConnectMove(e){
      if (!connecting) return;
      const host = canvasEl.getBoundingClientRect();
      const x1 = e.clientX - host.left; const y1 = e.clientY - host.top;
      const mx = (connecting.x0 + x1)/2;
      const d = `M ${connecting.x0} ${connecting.y0} C ${mx} ${connecting.y0}, ${mx} ${y1}, ${x1} ${y1}`;
      connecting.preview.setAttribute('d', d);
    }
    function endConnect(e){
      document.removeEventListener('mousemove', onConnectMove);
      document.removeEventListener('mouseup', endConnect);
      if (!connecting) return;
      // Buscar nodo bajo el puntero
      const el = document.elementFromPoint(e.clientX, e.clientY);
      let card = el;
      while (card && !card.classList?.contains('node')) card = card.parentElement;
      if (card && card.dataset.nodeId) {
        const target = card.dataset.nodeId;
        if (connecting.idx === null) {
          // Conexi√≥n desde nodo de inicio
          flow.nodes[connecting.nodeId].next = target;
        } else {
          const btns = flow.nodes[connecting.nodeId].buttons || [];
          btns[connecting.idx] = { title: btns[connecting.idx]?.title || 'Opci√≥n', next: target };
          flow.nodes[connecting.nodeId].buttons = btns;
        }
      }
      // limpiar preview
      if (connecting.preview && connecting.preview.parentNode) connecting.preview.parentNode.removeChild(connecting.preview);
      connecting = null;
      refresh();
    }

    function startDrag(e, el, id){
      e.preventDefault();
      const r = el.getBoundingClientRect();
      dragging = { id, el, offsetX: e.clientX - r.left, offsetY: e.clientY - r.top };
      document.addEventListener('mousemove', onDragMove);
      document.addEventListener('mouseup', endDrag);
    }
    function onDragMove(e){
      if (!dragging) return;
      const host = nodesEl.getBoundingClientRect();
      let x = e.clientX - host.left - dragging.offsetX;
      let y = e.clientY - host.top - dragging.offsetY;
      // Limitar a valores no negativos
      x = Math.max(0, x); y = Math.max(0, y);
      dragging.el.style.left = x + 'px';
      dragging.el.style.top = y + 'px';
      const n = flow.nodes[dragging.id];
      if (n) n.pos = { x, y };
      drawEdges();
    }
    function endDrag(){
      document.removeEventListener('mousemove', onDragMove);
      document.removeEventListener('mouseup', endDrag);
      dragging = null;
    }

    function saveFlow(){
      // Normalizar botones a solo next o id
      for (const k of Object.keys(flow.nodes)) {
        // Mantener posici√≥n actual
        const card = nodesEl.querySelector(`.node[data-node-id="${k}"]`);
        if (card) {
          const left = parseInt(card.style.left || '0', 10);
          const top = parseInt(card.style.top || '0', 10);
          flow.nodes[k].pos = { x: left, y: top };
        }
        flow.nodes[k].buttons = (flow.nodes[k].buttons||[]).slice(0, FLOW_LIMIT).map(b => {
          const out = { title: b.title||'Opci√≥n' };
          if (b.next) out.next = b.next; else if (b.id) out.id = b.id.trim();
          return out;
        });
        // Asegurar type/phone/keywords persisten
        flow.nodes[k].type = flow.nodes[k].type || 'action';
        if (flow.nodes[k].type==='advisor') flow.nodes[k].phone = (flow.nodes[k].phone||'').trim();
        if (flow.nodes[k].type==='start') {
          flow.nodes[k].keywords = (flow.nodes[k].keywords||'').trim();
          if (flow.nodes[k].next) flow.nodes[k].next = String(flow.nodes[k].next);
        }
      }
      const payload = JSON.stringify(flow, null, 2);
      document.getElementById('contentField').value = payload;
      document.getElementById('saveForm').submit();
    }

    function reloadFromServer(){
      window.location.reload();
    }

    // Primer render
    renderAll();
    window.addEventListener('resize', drawEdges);
    // Redibujar al desplazar el lienzo
    canvasEl.addEventListener('scroll', drawEdges);
  </script>
</body>
</html>
