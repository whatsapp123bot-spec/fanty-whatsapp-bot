<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Editor visual de flujo</title>
  <style>
    :root {
      --bg: #f6f7fb; --card: #fff; --text: #222; --muted: #666; --primary: #0b5ed7; --green:#198754; --red:#dc3545;
    }
    * { box-sizing: border-box; }
    body { margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { padding: 14px 20px; background: #5b2a86; color:#fff; display:flex; align-items:center; justify-content:space-between; }
    header .actions { display:flex; gap:8px; align-items:center; }
    .btn { padding:8px 12px; border-radius:8px; border:0; cursor:pointer; color:#fff; font-weight:600; }
    .btn.save { background: var(--green); }
    .btn.reload { background: var(--primary); }
  .btn.add { background: #7444a8; }
    .btn.del { background: var(--red); }
  .status-chip { font-size:12px; padding:2px 6px; border-radius:6px; color:#fff; margin-left:8px; }
  .status-chip.on { background:#198754; }
  .status-chip.off { background:#6c757d; }
    .wrap { display:grid; grid-template-columns: 260px 1fr; gap:12px; padding: 12px; height: calc(100vh - 60px); }
    .sidebar { background: var(--card); border-radius:12px; padding:10px; overflow:auto; box-shadow: 0 6px 16px rgba(0,0,0,.06); }
    .sidebar h3 { margin:6px 6px 10px; }
    .sidebar .node-item { display:flex; align-items:center; justify-content:space-between; padding:6px 8px; border-radius:8px; margin:4px 0; background:#fafafa; }
    .sidebar .node-item input { width: 120px; padding:4px 6px; }
    .sidebar .node-item button { padding:4px 8px; border-radius:6px; border:0; cursor:pointer; }
    .canvas { position:relative; background:#f0f2f7; border-radius:12px; overflow:auto; box-shadow: 0 6px 16px rgba(0,0,0,.06); }
    /* Contenedor de zoom */
    .stage { position:relative; width: 1200px; height: 800px; }
    .stage-inner { position:relative; transform-origin: 0 0; }
  .nodes { position:relative; padding:20px; min-width: 1200px; min-height: 800px; }
  .node { position:absolute; width: 300px; background:var(--card); border-radius:12px; padding:10px; box-shadow: 0 6px 16px rgba(0,0,0,.08); border:1px solid #e8e8f0; }
  .node .head { display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px; }
    .node .head input[type="text"] { flex:1; font-weight:700; padding:6px 8px; border:1px solid #ddd; border-radius:8px; }
    .node .head .start { font-size:12px; color:#fff; background:#ff7a59; padding:2px 6px; border-radius:6px; }
  .node .head .drag { cursor:move; user-select:none; padding:2px 6px; color:#888; }
    .node textarea { width:100%; min-height: 80px; padding:8px; border:1px solid #ddd; border-radius:8px; font-size:14px; }
    .btns { margin-top:6px; }
  .btns .row { display:grid; grid-template-columns: 1fr 26px auto; gap:6px; align-items:center; margin-bottom:6px; }
    .btns input, .btns select { padding:6px 8px; border:1px solid #ddd; border-radius:8px; }
    .btns .row .delbtn { background: var(--red); color:#fff; border:0; border-radius:8px; padding:6px 8px; cursor:pointer; }
    .btns .addRow { background: var(--primary); color:#fff; border:0; border-radius:8px; padding:6px 8px; cursor:pointer; }
    .legend { font-size:12px; color:var(--muted); margin-top:4px; }
  svg.lines { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:2; }
  .nodes { position:relative; padding:20px; min-width: 1200px; min-height: 800px; z-index:1; }
    .edge { stroke:#8a8aa8; stroke-width:2; marker-end: url(#arrow); }
  .connector { width:14px; height:14px; border-radius:50%; border:2px solid #7444a8; background:#fff; display:inline-block; }
  .connector:hover { background:#e7dbff; }
  .inlet { width:10px; height:10px; border-radius:50%; border:2px solid #8a8aa8; background:#fff; display:inline-block; margin-right:6px; }
  .preview { stroke:#7444a8; stroke-width:2; fill:none; stroke-dasharray:4 4; }
  .start-connector { position:absolute; bottom:10px; right:10px; width:14px; height:14px; border-radius:50%; border:2px solid #7444a8; background:#fff; }
  .start-connector:hover { background:#e7dbff; }
  /* Conector de nodo acciÃ³n (para flujos sin botones) */
  .node-connector { position:absolute; bottom:10px; right:10px; width:14px; height:14px; border-radius:50%; border:2px solid #7444a8; background:#fff; }
  .node-connector:hover { background:#e7dbff; }
  /* Assets UI */
  .assets { background:#fafbff; border:1px dashed #cfd4ff; padding:8px; border-radius:10px; margin-top:8px; }
  .assets .actions { display:flex; gap:8px; margin-bottom:6px; }
  .assets .actions button { background:#7444a8; color:#fff; border:0; border-radius:8px; padding:6px 8px; cursor:pointer; }
  .assets .list { display:flex; flex-direction:column; gap:6px; }
  .asset-item { display:flex; align-items:center; gap:8px; background:#fff; border:1px solid #eee; border-radius:8px; padding:6px; }
  .asset-item img { max-height:38px; border-radius:6px; }
  .asset-item .name { flex:1; font-size:13px; color:#333; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .asset-item button { background:var(--red); color:#fff; border:0; border-radius:8px; padding:4px 8px; cursor:pointer; }
  /* Zoom HUD */
  .zoom-hud { position:absolute; right:10px; bottom:10px; background:rgba(0,0,0,.6); color:#fff; padding:6px 8px; border-radius:8px; font-size:12px; z-index:3; }
    /* Overlay para elegir tipo de nodo */
    .overlay { position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:9999; }
    .overlay .panel { background:#fff; border-radius:12px; padding:16px; width:340px; box-shadow:0 8px 28px rgba(0,0,0,.25); }
    .overlay .panel h4 { margin:0 0 10px; }
    .overlay .choices { display:flex; flex-direction:column; gap:8px; }
    .overlay .choices button { padding:10px; border-radius:10px; border:1px solid #ddd; cursor:pointer; text-align:left; }
    .type-badge { font-size:12px; color:#fff; background:#6c757d; padding:2px 6px; border-radius:6px; margin-left:6px; }
  </style>
</head>
<body>
  <header>
    <div>
      <strong>Editor visual de flujo</strong>
      <span style="font-size:12px; opacity:.9; margin-left:8px;">(mÃ¡x. 3 botones por nodo)</span>
  <span id="statusChip" class="status-chip off">Inactivo</span>
    </div>
    <div class="actions">
      <button class="btn reload" style="background:#7444a8" onclick="openPreview()">ðŸ‘€ Vista previa</button>
      <button class="btn reload" onclick="reloadFromServer()">â†» Recargar</button>
      <button class="btn save" onclick="saveFlow()">ðŸ’¾ Guardar</button>
    </div>
  </header>

  <div class="wrap">
    <aside class="sidebar">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
        <h3 style="margin:0;">Nodos</h3>
  <button class="btn add" onclick="openAddNodeMenu()">+ AÃ±adir nodo</button>
      </div>
      <div style="margin-top:8px; display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="flowEnabledToggle" />
        <label for="flowEnabledToggle" style="font-size:13px; color:var(--muted)">Flujo activo</label>
      </div>
      <div style="margin-top:8px;">
        <label style="font-size:12px; color:var(--muted)">Nodo inicial</label>
        <select id="startNode" style="width:100%; padding:6px 8px; border:1px solid #ddd; border-radius:8px;"></select>
      </div>
      <div id="nodeList" style="margin-top:10px;"></div>
      <p class="legend">Tips:
        <br>â€¢ Arrastra el circulito hacia otra caja para conectar ese botÃ³n.
        <br>â€¢ Las flechas aparecen solo cuando el botÃ³n estÃ¡ conectado a otro nodo.
      </p>
    </aside>

    <section class="canvas">
      <div class="stage" id="stage">
        <div class="stage-inner" id="stageInner">
          <svg class="lines"></svg>
          <div class="nodes" id="nodes"></div>
        </div>
      </div>
      <div class="zoom-hud" id="zoomHud">100% (Ctrl + rueda)</div>
    </section>
  </div>

  <form id="saveForm" method="post" action="/flow?key={{ key }}" style="display:none;">
    <input type="hidden" name="content" id="contentField" />
  </form>

  <div id="toast" style="position:fixed; left:50%; transform:translateX(-50%); bottom:20px; background:#1e7e34; color:#fff; padding:10px 14px; border-radius:10px; box-shadow:0 6px 16px rgba(0,0,0,.2); font-weight:600; display:none; z-index:10000;">
    âœ… Flujo guardado correctamente.
  </div>

  <div id="overlay" class="overlay">
    <div class="panel">
      <h4>Nuevo nodo</h4>
      <div class="choices">
        <button onclick="addNodeOfType('action')">AcciÃ³n (mensaje + botones)</button>
        <button onclick="addNodeOfType('advisor')">Conversar con asesor (nÃºmero WhatsApp)</button>
        <button onclick="addNodeOfType('trigger')">Trigger (keywords / deeplink / IA)</button>
      </div>
      <div style="text-align:right; margin-top:10px;"><button class="btn del" onclick="closeAddNodeMenu()">Cerrar</button></div>
    </div>
  </div>

  <script>
    const FLOW_LIMIT = 3;
    let flow = {{ flow|tojson }};
    const UPLOAD_MAX_MB = {{ upload_max_mb|default(10) }};
  if (!flow || typeof flow !== 'object') flow = { start_node: null, nodes: {} };
    // Defaults para links (inyectados desde el backend)
    const DEFAULT_LINKS = {
      web: {{ (store_url or '')|tojson }},
      fb: {{ (fb_url or '')|tojson }},
      ig: {{ (ig_url or '')|tojson }},
      tiktok: {{ (tiktok_url or '')|tojson }}
    };

  const nodesEl = document.getElementById('nodes');
    const linesSvg = document.querySelector('svg.lines');
    const canvasEl = document.querySelector('.canvas');
    const stageEl = document.getElementById('stage');
    const stageInner = document.getElementById('stageInner');
    const zoomHud = document.getElementById('zoomHud');
    const startNodeSel = document.getElementById('startNode');
    const nodeListEl = document.getElementById('nodeList');
  let dragging = null; // { id, el, dx, dy }
  const overlay = document.getElementById('overlay');
  let ZOOM = 1.0; const MIN_ZOOM=0.5, MAX_ZOOM=2.0;

    function uid(base){
      let n = 1; let id = base || 'node';
      while(flow.nodes[id]) { id = (base||'node') + '_' + (++n); }
      return id;
    }

    function ensureDefaults(){
      if (typeof flow.enabled !== 'boolean') flow.enabled = true;
      if (!flow.nodes) flow.nodes = {};
      // Si no hay nodos, crear flujo base con trigger (saludo) -> welcome
      if (Object.keys(flow.nodes).length === 0) {
        flow.nodes = {
          'trigger_1': { type: 'trigger', trigger_type: 'keywords', patterns: 'hola, holi, buenas', enabled: true, next: 'welcome', pos: { x: 40, y: 40 } },
          'welcome': { type: 'action', text: 'ðŸ‘‹ Hola, soy Fanty, tu asistente virtual. Â¡Bienvenida!', buttons: [], pos: { x: 420, y: 40 } }
        };
        flow.start_node = 'welcome';
      }
      flow.start_node = flow.start_node || Object.keys(flow.nodes)[0] || null;
      for (const k of Object.keys(flow.nodes)) {
        flow.nodes[k].text = flow.nodes[k].text || '';
        flow.nodes[k].buttons = (flow.nodes[k].buttons || []).slice(0, FLOW_LIMIT);
        flow.nodes[k].type = flow.nodes[k].type || 'action';
      }
    }
  updateStatusChip();
    function renderAll(){
      ensureDefaults();
      
      // Sidebar list
      startNodeSel.innerHTML = '';
      Object.keys(flow.nodes).forEach(id => {
        const opt = document.createElement('option');
        opt.value = id; opt.textContent = id; startNodeSel.appendChild(opt);
      });
      startNodeSel.value = flow.start_node || '';

      nodeListEl.innerHTML = '';
      Object.keys(flow.nodes).forEach(id => nodeListEl.appendChild(renderNodeListItem(id)));

      // Toggle de flujo activo
      const flowToggle = document.getElementById('flowEnabledToggle');
      if (flowToggle) {
        flowToggle.checked = !!flow.enabled;
        flowToggle.onchange = () => { flow.enabled = !!flowToggle.checked; updateStatusChip(); };
      }

      // Canvas nodes
      nodesEl.innerHTML = '';
  let i=0;
      const cols = 3; const gapX=360, gapY=220; // simple auto-grid
      Object.entries(flow.nodes).forEach(([id, node]) => {
        // Si el nodo no tiene posiciÃ³n, asignar una por grilla y guardarla
        if (!node.pos || typeof node.pos.x !== 'number' || typeof node.pos.y !== 'number') {
          const x = (i % cols) * gapX + 40;
          const y = Math.floor(i / cols) * gapY + 40;
          node.pos = { x, y };
        }
        nodesEl.appendChild(renderNodeCard(id, node, node.pos.x, node.pos.y));
        i++;
      });

      updateStageSize();
      drawEdges();
      window.setTimeout(drawEdges, 50);
    }

    function renderNodeListItem(id){
  const wrap = document.createElement('div');
      wrap.className = 'node-item';
      const inp = document.createElement('input');
      inp.value = id; inp.title = 'ID del nodo';
      inp.addEventListener('change', () => renameNode(id, inp.value.trim()));
      const del = document.createElement('button');
      del.textContent = 'ðŸ—‘ï¸'; del.className='btn del';
      del.onclick = () => { deleteNode(id); };
      wrap.appendChild(inp); wrap.appendChild(del);
      return wrap;
    }

    function renderNodeCard(id, node, x, y){
  const el = document.createElement('div');
      el.className = 'node'; el.style.left = x+'px'; el.style.top = y+'px';
      el.dataset.nodeId = id;
      el.innerHTML = '';

      const head = document.createElement('div'); head.className='head';
      const drag = document.createElement('span'); drag.className='drag'; drag.textContent='â ¿'; drag.title='Arrastra para mover';
      head.appendChild(drag);
  const title = document.createElement('input'); title.type='text'; title.value = id; title.title='ID del nodo';
      title.addEventListener('change', () => renameNode(id, title.value.trim()));
  const inlet = document.createElement('span'); inlet.className='inlet'; inlet.title='Entrada de conexiones';
  head.appendChild(inlet);
  head.appendChild(title);
      const tBadge = document.createElement('span'); tBadge.className = 'type-badge'; tBadge.textContent = (node.type||'action'); head.appendChild(tBadge);
      if (flow.start_node === id) {
        const badge = document.createElement('span'); badge.textContent='inicio'; badge.className='start'; head.appendChild(badge);
      }
      el.appendChild(head);

      // Cuerpo segÃºn tipo de nodo
      if ((node.type||'action') === 'advisor') {
        const phone = document.createElement('input'); phone.placeholder='+51xxxxxxxxx (solo dÃ­gitos o con +)'; phone.value = node.phone||'';
        phone.style.width = '100%'; phone.style.marginBottom = '6px';
        phone.oninput = () => { flow.nodes[id].phone = phone.value.trim(); };
        el.appendChild(phone);
  const ta = document.createElement('textarea'); ta.value = node.text || 'Te estamos transfiriendo con una asesora humana. Un momento por favor.';
        ta.placeholder = 'Texto opcional que se enviarÃ¡'; ta.addEventListener('input', () => { flow.nodes[id].text = ta.value; });
        el.appendChild(ta);
  // Timeout de inactividad (minutos)
  const trow = document.createElement('div'); trow.style.display='grid'; trow.style.gridTemplateColumns='1fr 100px'; trow.style.gap='8px'; trow.style.alignItems='center'; trow.style.margin='6px 0';
  const tlab = document.createElement('label'); tlab.textContent = 'Cerrar por inactividad (min)'; tlab.style.fontSize='13px'; tlab.style.color='#333';
  const tnum = document.createElement('input'); tnum.type='number'; tnum.min='1'; tnum.max='720'; tnum.value = (node.timeout_min||node.human_timeout_min||15);
  tnum.oninput = ()=>{ const v = parseInt(tnum.value||'15',10); flow.nodes[id].timeout_min = isNaN(v)?15:Math.max(1, Math.min(720, v)); };
  trow.appendChild(tlab); trow.appendChild(tnum); el.appendChild(trow);
        // Links configurables (web y redes) con switches y URLs
        const linksBox = document.createElement('div'); linksBox.className='assets';
        const title = document.createElement('div'); title.style.fontWeight='700'; title.style.marginBottom='6px'; title.textContent='Links a mostrar mientras espera';
        linksBox.appendChild(title);
        const list = document.createElement('div'); list.style.display='flex'; list.style.flexDirection='column'; list.style.gap='6px';
        // Inicializar links del nodo si no existen
        const initIfNeeded = () => {
          if (!flow.nodes[id].links) {
            flow.nodes[id].links = {
              web: { enabled: !!DEFAULT_LINKS.web, url: DEFAULT_LINKS.web||'' },
              fb: { enabled: !!DEFAULT_LINKS.fb, url: DEFAULT_LINKS.fb||'' },
              ig: { enabled: !!DEFAULT_LINKS.ig, url: DEFAULT_LINKS.ig||'' },
              tiktok: { enabled: !!DEFAULT_LINKS.tiktok, url: DEFAULT_LINKS.tiktok||'' },
            };
            if (typeof flow.nodes[id].include_links === 'boolean') {
              const on = !!flow.nodes[id].include_links;
              Object.keys(flow.nodes[id].links).forEach(k => flow.nodes[id].links[k].enabled = on && !!flow.nodes[id].links[k].url);
            }
          }
        };
        initIfNeeded();

        const mkRow = (key, label) => {
          const row = document.createElement('div'); row.style.display='grid'; row.style.gridTemplateColumns='22px 1fr'; row.style.gap='8px'; row.style.alignItems='center';
          const chk = document.createElement('input'); chk.type='checkbox'; chk.checked = !!(flow.nodes[id].links?.[key]?.enabled);
          chk.onchange = () => { if (!flow.nodes[id].links) flow.nodes[id].links={}; if (!flow.nodes[id].links[key]) flow.nodes[id].links[key]={}; flow.nodes[id].links[key].enabled = !!chk.checked; syncIncludeLinks(); };
          const url = document.createElement('input'); url.placeholder = label + ' URL'; url.value = (flow.nodes[id].links?.[key]?.url || ''); url.style.width='100%';
          url.oninput = () => { if (!flow.nodes[id].links) flow.nodes[id].links={}; if (!flow.nodes[id].links[key]) flow.nodes[id].links[key]={}; flow.nodes[id].links[key].url = url.value.trim(); };
          row.appendChild(chk); row.appendChild(url);
          return row;
        };
        const syncIncludeLinks = () => {
          const l = flow.nodes[id].links || {};
          const anyOn = ['web','fb','ig','tiktok'].some(k => !!(l[k]?.enabled));
          flow.nodes[id].include_links = anyOn;
        };
        list.appendChild(mkRow('web', 'Web'));
        list.appendChild(mkRow('fb', 'Facebook'));
        list.appendChild(mkRow('ig', 'Instagram'));
        list.appendChild(mkRow('tiktok', 'TikTok'));
        const hint = document.createElement('div'); hint.className='legend'; hint.textContent='Activa/desactiva y edita las URLs que quieras mostrar.';
        linksBox.appendChild(list); linksBox.appendChild(hint);
        el.appendChild(linksBox);
      } else if ((node.type||'action') === 'trigger') {
        // Config UI para trigger
        const row = document.createElement('div'); row.style.display='grid'; row.style.gridTemplateColumns='1fr 1fr'; row.style.gap='8px'; row.style.margin='6px 0';
        const lab = document.createElement('label'); lab.textContent='Tipo de trigger'; lab.style.fontSize='13px'; lab.style.color='#333';
        const enabledWrap = document.createElement('div'); enabledWrap.style.display='flex'; enabledWrap.style.alignItems='center'; enabledWrap.style.gap='6px';
        const en = document.createElement('input'); en.type='checkbox'; en.checked = (typeof node.enabled==='boolean') ? !!node.enabled : true;
        en.onchange = ()=>{ flow.nodes[id].enabled = !!en.checked; };
        const enLab = document.createElement('label'); enLab.textContent='Activo'; enLab.style.fontSize='13px'; enLab.style.color='#333';
        enabledWrap.appendChild(en); enabledWrap.appendChild(enLab);
        const sel = document.createElement('select');
        ;['keywords','deeplink','ai'].forEach(t=>{ const o=document.createElement('option'); o.value=t; o.textContent=t; sel.appendChild(o); });
        sel.value = node.trigger_type || 'keywords';
        sel.onchange = ()=>{ flow.nodes[id].trigger_type = sel.value; refresh(); };
        row.appendChild(lab); row.appendChild(sel); el.appendChild(row);
        el.appendChild(enabledWrap);
        if ((node.trigger_type||'keywords') === 'keywords') {
          const kw = document.createElement('input'); kw.placeholder='Palabras clave separadas por coma'; kw.value = node.patterns||'';
          kw.style.width='100%'; kw.oninput = ()=>{ flow.nodes[id].patterns = kw.value; }; el.appendChild(kw);
        } else if ((node.trigger_type||'keywords') === 'deeplink') {
          const ex = document.createElement('textarea'); ex.placeholder='Frases exactas (una por lÃ­nea) â€” para wa.me?text=...'; ex.value = node.patterns||''; ex.style.minHeight='60px';
          ex.addEventListener('input', ()=>{ flow.nodes[id].patterns = ex.value; }); el.appendChild(ex);
        } else if ((node.trigger_type||'keywords') === 'ai') {
          const hint = document.createElement('div'); hint.className='legend'; hint.textContent='La IA decidirÃ¡ si arranca (ej: saludos/consulta general).'; el.appendChild(hint);
          const ins = document.createElement('textarea'); ins.placeholder='InstrucciÃ³n opcional a la IA (ej: inicia si parece saludo)';
          ins.value = node.instruction||''; ins.style.minHeight='60px'; ins.addEventListener('input', ()=>{ flow.nodes[id].instruction = ins.value; }); el.appendChild(ins);
        }
      } else {
        const ta = document.createElement('textarea'); ta.value = node.text || '';
        ta.placeholder = 'Texto del mensaje'; ta.addEventListener('input', () => { flow.nodes[id].text = ta.value; });
        el.appendChild(ta);
      }

  }
      if ((node.type||'action') === 'trigger') {
        const sc2 = document.createElement('span'); sc2.className='start-connector'; sc2.title='Arrastra para conectar este trigger con otro nodo';
        sc2.dataset.startConnector = id;
        sc2.addEventListener('mousedown', (e) => startConnect(e, id, null, sc2));
        el.appendChild(sc2);
      }

      if ((node.type||'action') !== 'advisor') {
        const btns = document.createElement('div'); btns.className='btns';
        (node.buttons||[]).forEach((b, idx) => btns.appendChild(renderButtonRow(id, b, idx)));
        const add = document.createElement('button'); add.className='addRow'; add.textContent='+ AÃ±adir botÃ³n';
        add.onclick = () => { addButton(id); };
        btns.appendChild(add);
        el.appendChild(btns);

        // Conector inferior derecho para enlazar siguiente nodo cuando no hay botones
        const nc = document.createElement('span'); nc.className='node-connector'; nc.title='Arrastra para conectar este nodo con otro (flujo lineal)';
        nc.dataset.nodeConnector = id;
        nc.addEventListener('mousedown', (e) => startConnect(e, id, null, nc));
        el.appendChild(nc);
      }

      // Drag & drop por la cabecera (manilla)
      drag.addEventListener('mousedown', (e) => startDrag(e, el, id));

      return el;
    }

    function renderButtonRow(nodeId, b, idx){
      const row = document.createElement('div'); row.className='row';
      const title = document.createElement('input'); title.placeholder='TÃ­tulo'; title.value = b.title || '';
      title.oninput = () => { flow.nodes[nodeId].buttons[idx].title = title.value; refresh(); };
      // Conector visual (drag para enlazar otro nodo)
      const connector = document.createElement('span'); connector.className='connector'; connector.title='Arrastra a otra caja para conectar';
      connector.dataset.connector = `${nodeId}:${idx}`;
      connector.addEventListener('mousedown', (e) => startConnect(e, nodeId, idx, connector));

      const del = document.createElement('button'); del.className='delbtn'; del.textContent='Quitar';
      del.onclick = () => { removeButton(nodeId, idx); };
      row.appendChild(title); row.appendChild(connector); row.appendChild(del);
      return row;
    }

    function openAddNodeMenu(){ overlay.style.display='flex'; }
    function closeAddNodeMenu(){ overlay.style.display='none'; }
    function addNodeOfType(type){
      const id = uid(type==='advisor'?'advisor':(type==='trigger'?'trigger':'node'));
      const base = { type: type||'action', text: '', buttons: [], pos: null };
      if (type==='advisor') base.phone='';
      if (type==='trigger') { base.trigger_type='keywords'; base.patterns=''; base.enabled = true; }
      flow.nodes[id] = base;
      if (!flow.start_node) flow.start_node = id; // como referencia de menÃº principal
      closeAddNodeMenu();
      refresh();
    }
    function deleteNode(id){
      if (!flow.nodes[id]) return;
      if (!confirm('Â¿Eliminar nodo '+id+'?')) return;
      delete flow.nodes[id];
      if (flow.start_node === id) flow.start_node = Object.keys(flow.nodes)[0] || null;
      // Quitar referencias next a este nodo
      for (const k of Object.keys(flow.nodes)) {
        const btns = flow.nodes[k].buttons||[];
        btns.forEach(b => { if (b.next === id) delete b.next; });
        // Quitar next desde nodos start
        if ((flow.nodes[k].type||'action') === 'start' && flow.nodes[k].next === id) {
          delete flow.nodes[k].next;
        }
      }
      refresh();
    }
    function renameNode(oldId, newId){
      if (!newId || newId===oldId || flow.nodes[newId]) { drawEdges(); return; }
      flow.nodes[newId] = flow.nodes[oldId]; delete flow.nodes[oldId];
      if (flow.start_node===oldId) flow.start_node=newId;
      for (const k of Object.keys(flow.nodes)) {
        (flow.nodes[k].buttons||[]).forEach(b => { if (b.next===oldId) b.next=newId; });
      }
      refresh();
    }
    function addButton(nodeId){
      const arr = flow.nodes[nodeId].buttons || (flow.nodes[nodeId].buttons=[]);
      if (arr.length >= FLOW_LIMIT) { alert('MÃ¡ximo '+FLOW_LIMIT+' botones.'); return; }
      const first = Object.keys(flow.nodes)[0] || null;
      arr.push({ title: 'OpciÃ³n', next: first });
      refresh();
    }
    function removeButton(nodeId, idx){
      const arr = flow.nodes[nodeId].buttons||[];
      arr.splice(idx, 1); refresh();
    }

    function refresh(){
      renderAll();
    }

    startNodeSel.addEventListener('change', () => {
      flow.start_node = startNodeSel.value || null; drawEdges();
    });

    function drawEdges(){
      // Limpia
      linesSvg.innerHTML = '<defs><marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#8a8aa8" /></marker></defs>';
      // Recalcular posiciones
      const host = stageInner.getBoundingClientRect();
      const nodeCards = Array.from(document.querySelectorAll('.node'));
      const pos = {};
      nodeCards.forEach(card => {
        const id = card.dataset.nodeId;
        const r = card.getBoundingClientRect();
        pos[id] = { x: (r.left - host.left)/ZOOM, y: (r.top - host.top)/ZOOM, w: r.width/ZOOM, h: r.height/ZOOM };
      });
      // Posiciones de conectores (por botÃ³n)
      const connPos = {};
      document.querySelectorAll('[data-connector]').forEach(el => {
        const r = el.getBoundingClientRect();
        connPos[el.dataset.connector] = { x: (r.left - host.left + r.width/2)/ZOOM, y: (r.top - host.top + r.height/2)/ZOOM };
      });
      // PosiciÃ³n de entrada por nodo (inlet)
      const inletPos = {};
      nodeCards.forEach(card => {
        const inlet = card.querySelector('.inlet');
        if (inlet) {
          const r = inlet.getBoundingClientRect();
          inletPos[card.dataset.nodeId] = { x: (r.left - host.left + r.width/2)/ZOOM, y: (r.top - host.top + r.height/2)/ZOOM };
        }
      });
      // PosiciÃ³n del conector de inicio por nodo
      const startConnPos = {};
      document.querySelectorAll('[data-start-connector]').forEach(el => {
        const r = el.getBoundingClientRect();
        startConnPos[el.dataset.startConnector] = { x: (r.left - host.left + r.width/2)/ZOOM, y: (r.top - host.top + r.height/2)/ZOOM };
      });
      // PosiciÃ³n del conector de nodo acciÃ³n
      const nodeConnPos = {};
      document.querySelectorAll('[data-node-connector]').forEach(el => {
        const r = el.getBoundingClientRect();
        nodeConnPos[el.dataset.nodeConnector] = { x: (r.left - host.left + r.width/2)/ZOOM, y: (r.top - host.top + r.height/2)/ZOOM };
      });
      // Pintar lÃ­neas next
      Object.entries(flow.nodes).forEach(([id, node]) => {
        (node.buttons||[]).forEach((b, idx) => {
          if (!b.next || !pos[id] || !pos[b.next]) return;
          const p1 = connPos[`${id}:${idx}`];
          const p2 = inletPos[b.next] || { x: pos[b.next].x, y: pos[b.next].y + pos[b.next].h/2 };
          if (!p1 || !p2) return;
          const x1 = p1.x, y1 = p1.y;
          const x2 = p2.x, y2 = p2.y;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2;
          const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d);
          // Atributos directos para compatibilidad en todos los navegadores
          path.setAttribute('class','edge');
          path.setAttribute('fill','none');
          path.setAttribute('stroke','#8a8aa8');
          path.setAttribute('stroke-width','2');
          path.setAttribute('marker-end','url(#arrow)');
          linesSvg.appendChild(path);
        });
  // Edge desde nodo start (si existe next)
        if ((node.type||'action') === 'start' && node.next && startConnPos[id] && inletPos[node.next]) {
          const p1 = startConnPos[id];
          const p2 = inletPos[node.next];
          const x1 = p1.x, y1 = p1.y; const x2 = p2.x, y2 = p2.y;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2; const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d); path.setAttribute('class','edge'); path.setAttribute('fill','none'); path.setAttribute('stroke','#8a8aa8'); path.setAttribute('stroke-width','2'); path.setAttribute('marker-end','url(#arrow)'); linesSvg.appendChild(path);
        }
        // Edge desde nodo trigger (si existe next)
        if ((node.type||'action') === 'trigger' && node.next && startConnPos[id] && inletPos[node.next]) {
          const p1 = startConnPos[id];
          const p2 = inletPos[node.next];
          const x1 = p1.x, y1 = p1.y; const x2 = p2.x, y2 = p2.y;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2; const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d); path.setAttribute('class','edge'); path.setAttribute('fill','none'); path.setAttribute('stroke','#8a8aa8'); path.setAttribute('stroke-width','2'); path.setAttribute('marker-end','url(#arrow)'); linesSvg.appendChild(path);
        }
        // Edge desde nodo action (si existe next)
        if ((node.type||'action') === 'action' && node.next && nodeConnPos[id] && inletPos[node.next]) {
          const p1 = nodeConnPos[id];
          const p2 = inletPos[node.next];
          const x1 = p1.x, y1 = p1.y; const x2 = p2.x, y2 = p2.y;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const mx = (x1 + x2)/2; const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
          path.setAttribute('d', d); path.setAttribute('class','edge'); path.setAttribute('fill','none'); path.setAttribute('stroke','#8a8aa8'); path.setAttribute('stroke-width','2'); path.setAttribute('marker-end','url(#arrow)'); linesSvg.appendChild(path);
        }
      });
    }

    // ConexiÃ³n visual (drag desde el conector a otro nodo)
  let connecting = null; // { nodeId, idx|null, x0, y0, preview }
    function startConnect(e, nodeId, idx, connectorEl){
      e.preventDefault();
      const rect = connectorEl.getBoundingClientRect();
      const host = stageInner.getBoundingClientRect();
      const x0 = (rect.left - host.left + rect.width/2)/ZOOM;
      const y0 = (rect.top - host.top + rect.height/2)/ZOOM;
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('class','preview');
      linesSvg.appendChild(p);
  connecting = { nodeId, idx, x0, y0, preview: p };
      document.addEventListener('mousemove', onConnectMove);
      document.addEventListener('mouseup', endConnect);
    }
    function onConnectMove(e){
      if (!connecting) return;
      const host = stageInner.getBoundingClientRect();
      const x1 = (e.clientX - host.left)/ZOOM; const y1 = (e.clientY - host.top)/ZOOM;
      const mx = (connecting.x0 + x1)/2;
      const d = `M ${connecting.x0} ${connecting.y0} C ${mx} ${connecting.y0}, ${mx} ${y1}, ${x1} ${y1}`;
      connecting.preview.setAttribute('d', d);
    }
    function endConnect(e){
      document.removeEventListener('mousemove', onConnectMove);
      document.removeEventListener('mouseup', endConnect);
      if (!connecting) return;
      // Buscar nodo bajo el puntero
      const el = document.elementFromPoint(e.clientX, e.clientY);
      let card = el;
      while (card && !card.classList?.contains('node')) card = card.parentElement;
      if (card && card.dataset.nodeId) {
        const target = card.dataset.nodeId;
        if (connecting.idx === null) {
          // ConexiÃ³n desde nodo de inicio
          flow.nodes[connecting.nodeId].next = target;
        } else {
          const btns = flow.nodes[connecting.nodeId].buttons || [];
          btns[connecting.idx] = { title: btns[connecting.idx]?.title || 'OpciÃ³n', next: target };
          flow.nodes[connecting.nodeId].buttons = btns;
        }
      }
      // limpiar preview
      if (connecting.preview && connecting.preview.parentNode) connecting.preview.parentNode.removeChild(connecting.preview);
      connecting = null;
      refresh();
    }

    function startDrag(e, el, id){
      e.preventDefault();
      const r = el.getBoundingClientRect();
      dragging = { id, el, offsetX: (e.clientX - r.left)/ZOOM, offsetY: (e.clientY - r.top)/ZOOM };
      document.addEventListener('mousemove', onDragMove);
      document.addEventListener('mouseup', endDrag);
    }
    function onDragMove(e){
      if (!dragging) return;
      const host = stageInner.getBoundingClientRect();
      let x = (e.clientX - host.left)/ZOOM - dragging.offsetX;
      let y = (e.clientY - host.top)/ZOOM - dragging.offsetY;
      // Limitar a valores no negativos
      x = Math.max(0, x); y = Math.max(0, y);
      dragging.el.style.left = x + 'px';
      dragging.el.style.top = y + 'px';
      const n = flow.nodes[dragging.id];
      if (n) n.pos = { x, y };
      drawEdges();
    }
    function endDrag(){
      document.removeEventListener('mousemove', onDragMove);
      document.removeEventListener('mouseup', endDrag);
      dragging = null;
    }

    function saveFlow(){
      // Normalizar botones a solo next o id
      for (const k of Object.keys(flow.nodes)) {
        // Mantener posiciÃ³n actual
        const card = nodesEl.querySelector(`.node[data-node-id="${k}"]`);
        if (card) {
          const left = parseInt(card.style.left || '0', 10);
          const top = parseInt(card.style.top || '0', 10);
          flow.nodes[k].pos = { x: left, y: top };
        }
        flow.nodes[k].buttons = (flow.nodes[k].buttons||[]).slice(0, FLOW_LIMIT).map(b => {
          const out = { title: b.title||'OpciÃ³n' };
          if (b.next) out.next = b.next; else if (b.id) out.id = b.id.trim();
          return out;
        });
        // Asegurar type/phone/keywords/assets persisten
        flow.nodes[k].type = flow.nodes[k].type || 'action';
        if (flow.nodes[k].type==='advisor') {
          flow.nodes[k].phone = (flow.nodes[k].phone||'').trim();
          // Normalizar links
          const links = flow.nodes[k].links;
          const norm = {};
          ['web','fb','ig','tiktok'].forEach(key => {
            const it = links && links[key] ? links[key] : null;
            if (it && (it.url||'').trim()) {
              norm[key] = { enabled: !!it.enabled, url: (it.url||'').trim() };
            }
          });
          if (Object.keys(norm).length > 0) {
            flow.nodes[k].links = norm;
            flow.nodes[k].include_links = Object.values(norm).some(v => v.enabled);
          } else {
            delete flow.nodes[k].links;
            flow.nodes[k].include_links = !!flow.nodes[k].include_links; // mantener compatibilidad
          }
          // Timeout por inactividad
          const tm = parseInt(flow.nodes[k].timeout_min||flow.nodes[k].human_timeout_min||15, 10);
          flow.nodes[k].timeout_min = isNaN(tm)?15:Math.max(1, Math.min(720, tm));
        }
        // (start eliminado del editor)
        if (flow.nodes[k].type==='trigger') {
          const t = (flow.nodes[k].trigger_type||'keywords');
          flow.nodes[k].trigger_type = t;
          flow.nodes[k].enabled = (typeof flow.nodes[k].enabled === 'boolean') ? !!flow.nodes[k].enabled : true;
          if (t === 'ai') {
            const ins = (flow.nodes[k].instruction||'').toString();
            if (ins.trim()) flow.nodes[k].instruction = ins.trim(); else delete flow.nodes[k].instruction;
            delete flow.nodes[k].patterns;
          } else {
            const pat = (flow.nodes[k].patterns||'').toString();
            flow.nodes[k].patterns = pat;
            delete flow.nodes[k].instruction;
          }
          if (flow.nodes[k].next) flow.nodes[k].next = String(flow.nodes[k].next);
          if ('text' in flow.nodes[k]) delete flow.nodes[k].text;
        }
        // assets eliminados del editor
      }
  const payload = JSON.stringify(flow, null, 2);
      // Guardar por fetch JSON para no salir del builder
      const fd = new FormData();
      fd.append('content', payload);
      fetch('/flow?key={{ key }}&format=json', { method: 'POST', body: fd })
        .then(async (r) => {
          if (!r.ok) throw new Error((await r.json()).error || 'Error al guardar');
          return r.json();
        })
        .then(() => showToast('âœ… Flujo guardado correctamente.'))
        .catch(err => showToast('âŒ Error al guardar: ' + err.message, true));
    }

    function reloadFromServer(){
      window.location.reload();
    }

    function openPreview(){
      // Abre el simulador tipo WhatsApp en una pestaÃ±a nueva
      window.open('/chat','_blank');
    }

    function showToast(msg, isError){
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.style.background = isError ? '#dc3545' : '#1e7e34';
      t.style.display = 'block';
      clearTimeout(window.__toastTimer);
      window.__toastTimer = setTimeout(() => { t.style.display = 'none'; }, 2000);
    }

    function updateStatusChip(){
      const chip = document.getElementById('statusChip');
      if (!chip) return;
      const on = !!(flow && flow.enabled);
      chip.textContent = on ? 'Activo' : 'Inactivo';
      chip.classList.toggle('on', on);
      chip.classList.toggle('off', !on);
    }

    // Upload helpers eliminados

    // Zoom helpers
    function setZoom(nextZoom, pivotClientX, pivotClientY){
      const old = ZOOM; const nz = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, nextZoom));
      if (Math.abs(nz - old) < 0.001) return;
      // Mantener foco bajo el cursor
      const rect = canvasEl.getBoundingClientRect();
      const px = (pivotClientX ?? (rect.left + rect.width/2)) - rect.left + canvasEl.scrollLeft;
      const py = (pivotClientY ?? (rect.top + rect.height/2)) - rect.top + canvasEl.scrollTop;
      const worldX = px / old; const worldY = py / old;

      ZOOM = nz;
      updateStageSize();
      drawEdges();

      const newPx = worldX * ZOOM;
      const newPy = worldY * ZOOM;
      canvasEl.scrollLeft = newPx - ((pivotClientX ?? (rect.left + rect.width/2)) - rect.left);
      canvasEl.scrollTop = newPy - ((pivotClientY ?? (rect.top + rect.height/2)) - rect.top);
      zoomHud.textContent = Math.round(ZOOM*100) + '% (Ctrl + rueda)';
    }
    function updateStageSize(){
      // calcular mundo segÃºn DOM real (mÃ¡s preciso con textareas/botones)
      let maxX = 1200, maxY = 800;
      const host = stageInner.getBoundingClientRect();
      const cards = Array.from(document.querySelectorAll('.node'));
      cards.forEach(card => {
        const r = card.getBoundingClientRect();
        const right = (r.right - host.left)/ZOOM;
        const bottom = (r.bottom - host.top)/ZOOM;
        maxX = Math.max(maxX, right + 200);
        maxY = Math.max(maxY, bottom + 200);
      });
      stageEl.style.width = (maxX * ZOOM) + 'px';
      stageEl.style.height = (maxY * ZOOM) + 'px';
      stageInner.style.width = maxX + 'px';
      stageInner.style.height = maxY + 'px';
      stageInner.style.transform = `scale(${ZOOM})`;
    }

    canvasEl.addEventListener('wheel', (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        setZoom(ZOOM * factor, e.clientX, e.clientY);
      }
    }, { passive:false });

    // Primer render
    renderAll();
    window.addEventListener('resize', drawEdges);
    // Redibujar al desplazar el lienzo
    canvasEl.addEventListener('scroll', drawEdges);
  </script>
</body>
</html>
